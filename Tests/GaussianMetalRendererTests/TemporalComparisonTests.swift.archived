import XCTest
import Metal
import simd
@testable import GaussianMetalRenderer

/// Compare temporal vs non-temporal rendering to verify temporal mode works
final class TemporalComparisonTests: XCTestCase {
    var device: MTLDevice!
    var queue: MTLCommandQueue!
    var encoder: TellusimPipelineEncoder!

    override func setUp() {
        super.setUp()
        device = MTLCreateSystemDefaultDevice()!
        queue = device.makeCommandQueue()!
        encoder = try! TellusimPipelineEncoder(device: device)
    }

    /// Helper to create camera uniforms
    func createCamera(width: Int, height: Int) -> CameraUniformsSwift {
        let view = simd_float4x4(
            SIMD4<Float>(1, 0, 0, 0),
            SIMD4<Float>(0, 1, 0, 0),
            SIMD4<Float>(0, 0, 1, 0),
            SIMD4<Float>(0, 0, 0, 1)
        )

        let fov: Float = 60.0 * .pi / 180.0
        let aspect = Float(width) / Float(height)
        let near: Float = 0.1
        let far: Float = 100.0
        let tanHalfFov = tan(fov / 2.0)

        let proj = simd_float4x4(
            SIMD4<Float>(1.0 / (aspect * tanHalfFov), 0, 0, 0),
            SIMD4<Float>(0, 1.0 / tanHalfFov, 0, 0),
            SIMD4<Float>(0, 0, -(far + near) / (far - near), -1),
            SIMD4<Float>(0, 0, -2.0 * far * near / (far - near), 0)
        )

        return CameraUniformsSwift(
            viewMatrix: view,
            projectionMatrix: proj,
            cameraCenter: SIMD3<Float>(0, 0, 0),
            pixelFactor: 1.0,
            focalX: Float(width) / (2.0 * tanHalfFov),
            focalY: Float(height) / (2.0 * tanHalfFov),
            width: Float(width),
            height: Float(height),
            nearPlane: near,
            farPlane: far,
            shComponents: 0,
            gaussianCount: 0
        )
    }

    // Use PackedWorldGaussian from the module (defined in KernelTypes.swift)

    /// Per-pixel comparison: temporal vs standard rendering
    func testTemporalVsStandardPixelComparison() throws {
        // Temporal pipeline has TWO separate capacities:
        // 1. sortedMaxPerTile - maintained sorted list (large, holds ALL gaussians per tile)
        // 2. candidatesPerFrame - new candidates scattered each frame (smaller, merged incrementally)
        let gaussianCount = 512
        let width = 256
        let height = 256
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        // INCREMENTAL CONVERGENCE: M << N
        // M = candidatesPerFrame (how many NEW candidates we can add per frame)
        // N = sortedMaxPerTile (total maintained sorted list size)
        // With M=8 and ~27 gaussians per tile, needs ~4 frames to see all candidates
        let sortedMaxPerTile: UInt32 = 256   // N: maintained sorted list per tile (must be >= max per tile, which can be 215)
        let candidatesPerFrame: UInt32 = 32   // M: candidates per frame (SMALL for efficiency - different subset each frame via hash)
        let maxAssignments = gaussianCount * 32  // For standard pipeline

        // Shared buffers
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        // Fill test data - deterministic for reproducibility
        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)  // Fixed seed for reproducibility
        for i in 0..<gaussianCount {
            let x = Float(drand48()) * 2.0 - 1.0
            let y = Float(drand48()) * 2.0 - 1.0
            let z = Float(drand48()) * 3.0 + 3.0  // 3-6 depth

            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(x, y, z),
                scale: SIMD3<Float>(0.15, 0.15, 0.15),  // Moderate size for multi-tile coverage
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: 0.8
            )

            harmonicsPtr[i * 3 + 0] = Float(drand48()) * 0.5 + 0.3
            harmonicsPtr[i * 3 + 1] = Float(drand48()) * 0.5 + 0.3
            harmonicsPtr[i * 3 + 2] = Float(drand48()) * 0.5 + 0.3
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // ========== STANDARD PIPELINE ==========
        let stdCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let stdHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let stdTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let stdTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let stdPartialSums = device.makeBuffer(length: 1024 * 4, options: .storageModeShared)!
        let stdSortKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdSortIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!

        let stdColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        stdColorDesc.usage = [.shaderRead, .shaderWrite]
        stdColorDesc.storageMode = .shared
        let stdColorTex = device.makeTexture(descriptor: stdColorDesc)!

        let stdDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        stdDepthDesc.usage = [.shaderRead, .shaderWrite]
        stdDepthDesc.storageMode = .shared
        let stdDepthTex = device.makeTexture(descriptor: stdDepthDesc)!

        // Clear header
        let stdHeaderPtr = stdHeader.contents().bindMemory(to: UInt32.self, capacity: 4)
        stdHeaderPtr[0] = 0
        stdHeaderPtr[1] = 0

        // Run standard pipeline
        if let cb = queue.makeCommandBuffer() {
            encoder.encode(
                commandBuffer: cb,
                worldGaussians: worldBuffer,
                harmonics: harmonicsBuffer,
                camera: camera,
                gaussianCount: gaussianCount,
                tilesX: tilesX,
                tilesY: tilesY,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                surfaceWidth: width,
                surfaceHeight: height,
                compactedGaussians: stdCompacted,
                compactedHeader: stdHeader,
                tileCounts: stdTileCounts,
                tileOffsets: stdTileOffsets,
                partialSums: stdPartialSums,
                sortKeys: stdSortKeys,
                sortIndices: stdSortIndices,
                maxCompacted: maxCompacted,
                maxAssignments: maxAssignments,
                useHalfWorld: false,
                tempSortKeys: stdTempKeys,
                tempSortIndices: stdTempIndices
            )

            encoder.encodeRender(
                commandBuffer: cb,
                compactedGaussians: stdCompacted,
                tileOffsets: stdTileOffsets,
                tileCounts: stdTileCounts,
                sortedIndices: stdSortIndices,
                colorTexture: stdColorTex,
                depthTexture: stdDepthTex,
                tilesX: tilesX,
                tilesY: tilesY,
                width: width,
                height: height,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                whiteBackground: false
            )

            cb.commit()
            cb.waitUntilCompleted()
        }

        let stdVisible = stdHeaderPtr[0]
        print("Standard: visible=\(stdVisible)/\(gaussianCount)")

        // Debug: Print standard sorted values for tile 0
        let stdTileCountsPtr = stdTileCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)

        // Count total assignments from tile counts
        var totalStdAssignments: UInt32 = 0
        var maxTileCount: UInt32 = 0
        var tilesWithOver64: Int = 0
        var overflowAmount: UInt32 = 0
        for t in 0..<tileCount {
            let cnt = stdTileCountsPtr[t]
            totalStdAssignments += cnt
            if cnt > maxTileCount { maxTileCount = cnt }
            if cnt > 64 {
                tilesWithOver64 += 1
                overflowAmount += (cnt - 64)
            }
        }
        print("Total standard assignments: \(totalStdAssignments) (maxAssignments=\(maxAssignments))")
        print("Max per-tile: \(maxTileCount), tiles with >64: \(tilesWithOver64), overflow: \(overflowAmount)")
        let stdTileOffsetsPtr = stdTileOffsets.contents().bindMemory(to: UInt32.self, capacity: tileCount + 1)
        let stdSortKeysPtr = stdSortKeys.contents().bindMemory(to: UInt32.self, capacity: maxAssignments)
        let stdSortIndicesPtr = stdSortIndices.contents().bindMemory(to: UInt32.self, capacity: maxAssignments)

        // Use tile 50 (in the middle where there should be gaussians)
        var testTile = 50
        // Find a tile with gaussians
        for t in 40..<80 {
            if stdTileCountsPtr[t] > 10 {
                testTile = t
                break
            }
        }
        print("\n=== STANDARD SORTED (tile \(testTile)) ===")
        let stdTileCount = stdTileCountsPtr[testTile]
        let stdTileOffset = stdTileOffsetsPtr[testTile]
        print("Tile \(testTile): count=\(stdTileCount), offset=\(stdTileOffset)")
        // Read compactedToWorld from temporal's projection to get world indices
        // Note: This won't work since temporal hasn't run yet, so we just show compacted indices
        for i in 0..<min(Int(stdTileCount), 15) {
            let key = stdSortKeysPtr[Int(stdTileOffset) + i]
            let compIdx = stdSortIndicesPtr[Int(stdTileOffset) + i]
            print("  [\(i)] key=\(key) compactedIdx=\(compIdx)")
        }

        // Read standard output
        var stdPixels = [Float16](repeating: 0, count: width * height * 4)
        stdColorTex.getBytes(&stdPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        // ========== BUILD MAPPINGS FOR stdCompacted ==========
        // To fairly compare, temporal must use the SAME compacted buffer as standard.
        // Build worldToCompacted and compactedToWorld by matching positions.
        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        let compactedToWorldPtr = compactedToWorld.contents().bindMemory(to: UInt32.self, capacity: maxCompacted)
        let worldToCompactedPtr = worldToCompacted.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)

        // Initialize worldToCompacted to INVALID
        for i in 0..<gaussianCount {
            worldToCompactedPtr[i] = 0xFFFFFFFF
        }

        // Match stdCompacted positions to world gaussian positions
        let stdCompactedPtr = stdCompacted.contents().bindMemory(to: CompactedGaussianSwift.self, capacity: maxCompacted)
        for compactedIdx in 0..<Int(stdVisible) {
            let compactedPos = SIMD2<Float>(stdCompactedPtr[compactedIdx].position_color.x,
                                            stdCompactedPtr[compactedIdx].position_color.y)

            // Find matching world gaussian by projected position
            // (This works because projection is deterministic for same input)
            var bestWorldIdx: UInt32 = 0xFFFFFFFF
            var bestDist: Float = Float.infinity
            for worldIdx in 0..<gaussianCount {
                // Skip already-matched
                if worldToCompactedPtr[worldIdx] != 0xFFFFFFFF { continue }

                // Project world position to screen
                let worldPos = worldPtr[worldIdx].position
                let viewPos = camera.viewMatrix * SIMD4<Float>(worldPos, 1.0)
                let clipPos = camera.projectionMatrix * viewPos
                if abs(clipPos.w) < 1e-6 { continue }
                let ndcX = clipPos.x / clipPos.w
                let ndcY = clipPos.y / clipPos.w
                let px = ((ndcX + 1.0) * camera.width - 1.0) * 0.5
                let py = ((ndcY + 1.0) * camera.height - 1.0) * 0.5

                let dist = abs(px - compactedPos.x) + abs(py - compactedPos.y)
                if dist < bestDist {
                    bestDist = dist
                    bestWorldIdx = UInt32(worldIdx)
                }
            }

            if bestWorldIdx != 0xFFFFFFFF && bestDist < 0.01 {
                compactedToWorldPtr[compactedIdx] = bestWorldIdx
                worldToCompactedPtr[Int(bestWorldIdx)] = UInt32(compactedIdx)
            }
        }

        // Verify mappings
        var mappedCount = 0
        for i in 0..<Int(stdVisible) {
            if compactedToWorldPtr[i] != 0xFFFFFFFF { mappedCount += 1 }
        }
        print("Built mappings for stdCompacted: \(mappedCount)/\(stdVisible) gaussians mapped")

        // ========== DEPTH-BASED TEMPORAL PIPELINE ==========
        // Use same tile size as standard for fair comparison
        // NOW USING stdCompacted instead of separate tmpCompacted!
        let temporalTileWidth = tileWidth
        let temporalTileHeight = tileHeight
        let temporalTilesX = tilesX
        let temporalTilesY = tilesY
        let temporalTileCount = tileCount

        // Use stdCompacted for temporal (no separate tmpCompacted needed!)
        // Mappings were built above from stdCompacted

        let sortedSlots = temporalTileCount * Int(sortedMaxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: temporalTileCount * 4, options: .storageModeShared)!

        let candidateSlots = temporalTileCount * Int(candidatesPerFrame)
        let candCounts = device.makeBuffer(length: temporalTileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        // Bloom filters for O(1) duplicate detection (64 uints = 2048 bits per tile)
        let bloomFilters = device.makeBuffer(length: temporalTileCount * 64 * 4, options: .storageModeShared)!

        let tmpColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        tmpColorDesc.usage = [.shaderRead, .shaderWrite]
        tmpColorDesc.storageMode = .shared
        let tmpColorTex = device.makeTexture(descriptor: tmpColorDesc)!

        let tmpDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        tmpDepthDesc.usage = [.shaderRead, .shaderWrite]
        tmpDepthDesc.storageMode = .shared
        let tmpDepthTex = device.makeTexture(descriptor: tmpDepthDesc)!

        // Initialize temporal sorted buffers with EMPTY lists
        // This ensures only gaussians that actually intersect tiles via scatter get added
        // (Random init could include non-intersecting gaussians that never get pruned)
        let sortedKeysPtr = sortedKeys.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedIndicesPtr = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: temporalTileCount)

        for t in 0..<temporalTileCount {
            sortedCountsPtr[t] = 0  // Start with EMPTY list

            let tileOffset = t * Int(sortedMaxPerTile)
            // All slots invalid
            for i in 0..<Int(sortedMaxPerTile) {
                sortedKeysPtr[tileOffset + i] = 0xFFFFFFFF
                sortedIndicesPtr[tileOffset + i] = 0xFFFFFFFF
            }
        }
        print("Initialized temporal sorted lists with EMPTY lists (will build via scatter + insertion sort)")

        // Helper to compute loss vs standard
        func computeLoss() -> (avgDiff: Float, nonZero: Int, totalSorted: UInt32) {
            var tmpPixels = [Float16](repeating: 0, count: width * height * 4)
            tmpColorTex.getBytes(&tmpPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

            var totalDiff: Float = 0
            var nonZero = 0
            for i in stride(from: 0, to: stdPixels.count, by: 4) {
                let stdR = Float(stdPixels[i])
                let stdG = Float(stdPixels[i + 1])
                let stdB = Float(stdPixels[i + 2])
                let tmpR = Float(tmpPixels[i])
                let tmpG = Float(tmpPixels[i + 1])
                let tmpB = Float(tmpPixels[i + 2])
                if tmpR > 0 || tmpG > 0 || tmpB > 0 { nonZero += 1 }
                totalDiff += abs(stdR - tmpR) + abs(stdG - tmpG) + abs(stdB - tmpB)
            }

            let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: temporalTileCount)
            var totalSorted: UInt32 = 0
            for t in 0..<temporalTileCount { totalSorted += sortedCountsPtr[t] }

            return (totalDiff / Float(width * height), nonZero, totalSorted)
        }

        // NO temporal projection needed - using stdCompacted with mappings built above!

        // Debug: Verify compactedToWorld mapping (already built from stdCompacted)
        print("=== DEBUG: compactedToWorld mapping (from stdCompacted) ===")
        for i in 0..<min(10, Int(stdVisible)) {
            let worldIdx = compactedToWorldPtr[i]
            let reverseCheck = worldIdx < gaussianCount ? worldToCompactedPtr[Int(worldIdx)] : 0xFFFFFFFF
            print("  compactedToWorld[\(i)] = \(worldIdx) (reverse: worldToCompacted[\(worldIdx)] = \(reverseCheck))")
        }

        // Debug: check tile bounds from stdCompacted
        // NOTE: max_tile is EXCLUSIVE (first tile NOT covered)
        print("Using stdCompacted with \(stdVisible) visible gaussians")
        print("Checking tile bounds for first 10 gaussians (EXCLUSIVE max):")
        var multiTileCount = 0
        var expectedTotalAssignments: UInt32 = 0
        for i in 0..<Int(stdVisible) {
            let g = stdCompactedPtr[i]
            let minT = g.min_tile
            let maxT = g.max_tile
            // EXCLUSIVE max: numTiles = (maxT - minT) NOT (maxT - minT + 1)
            let tilesWide = max(0, Int(maxT.x) - Int(minT.x))
            let tilesHigh = max(0, Int(maxT.y) - Int(minT.y))
            let numTiles = tilesWide * tilesHigh
            expectedTotalAssignments += UInt32(numTiles)
            if numTiles > 1 { multiTileCount += 1 }
            if i < 10 {
                print("  [\(i)] min=(\(minT.x),\(minT.y)) max=(\(maxT.x),\(maxT.y)) tiles=\(numTiles)")
            }
        }
        print("Gaussians touching multiple tiles: \(multiTileCount)/\(stdVisible)")
        print("Expected total tile assignments from stdCompacted bounds: \(expectedTotalAssignments) (BEFORE FlashGS)")
        print("Actual standard scatter: \(totalStdAssignments) (AFTER FlashGS)")
        print("stdHeader visibleCount: \(stdHeaderPtr[0]) (used by temporal scatter)")

        print("\n========== CONVERGENCE TEST ==========")
        print("Frame | AvgLoss  | NonZero | Candidates | TotalSorted")
        print("------|----------|---------|------------|------------")

        // Run temporal pipeline - for static scene, should converge after all gaussians are scattered
        // With M=32 and max 215 per tile, need enough frames for hash to cover all gaussians
        let numFrames = 200
        for frame in 0..<numFrames {
            guard let cb = queue.makeCommandBuffer() else { continue }

            // Clear candidate counts and indices EVERY frame (honest scatter uses atomics)
            // GPU clear via encodeClearTemporal - but we only need candidate clearing, not worldToCompacted
            let candCountsPtr = candCounts.contents().bindMemory(to: UInt32.self, capacity: temporalTileCount)
            for t in 0..<temporalTileCount {
                candCountsPtr[t] = 0
            }
            let totalCandidateSlots = temporalTileCount * Int(candidatesPerFrame)
            let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: totalCandidateSlots)
            for i in 0..<totalCandidateSlots {
                candIndicesPtr[i] = 0xFFFFFFFF
            }

            // Recompute DEPTH keys for existing sorted list
            encoder.encodeRecomputeSortedDepths(
                commandBuffer: cb,
                sortedKeys: sortedKeys,
                sortedIndices: sortedIndices,
                sortedCounts: sortedCounts,
                compactedGaussians: stdCompacted,
                worldToCompacted: worldToCompacted,
                maxPerTile: sortedMaxPerTile,
                tileCount: temporalTileCount,
                tilesX: tilesX
            )

            // Scatter candidates using DEPTH-based stochastic scatter
            // Uses (depth16 << 16) | compactedIdx for stable sorting (matches standard!)
            // Frame-varying slot selection: slot = hash(compactedIdx, frameId, tileId) % maxCandidates
            // FlashGS intersection test ensures we only scatter to tiles that actually intersect
            encoder.encodeScatterCandidatesDepth(
                commandBuffer: cb,
                compactedGaussians: stdCompacted,
                compactedHeader: stdHeader,
                compactedToWorld: compactedToWorld,
                candidateKeys: candKeys,
                candidateIndices: candIndices,
                tilesX: temporalTilesX,
                maxCandidates: candidatesPerFrame,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                maxGaussians: maxCompacted,
                frameId: UInt32(frame)  // Time-varying slot for different candidates each frame
            )

            // Debug: Check candidate keys/indices BEFORE insertion sort (frame 0 only)
            if frame == 0 {
                cb.commit()
                cb.waitUntilCompleted()

                // Count valid candidates (M slots per tile)
                let candIndPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)
                let tile41Offset = 41 * Int(candidatesPerFrame)
                var validCount = 0
                for c in 0..<Int(candidatesPerFrame) {
                    if candIndPtr[tile41Offset + c] != 0xFFFFFFFF { validCount += 1 }
                }
                print("Frame 0: Valid candidates in tile 41: \(validCount)/\(candidatesPerFrame) (M=\(candidatesPerFrame), N=\(sortedMaxPerTile))")

                // Create new command buffer for insertion sort
                guard let cb2 = queue.makeCommandBuffer() else { continue }

                // Insertion sort (recomputes keys from indices to handle scatter race)
                encoder.encodeInsertionSortTemporal(
                    commandBuffer: cb2,
                    sortedKeys: sortedKeys,
                    sortedIndices: sortedIndices,
                    sortedCounts: sortedCounts,
                    bloomFilters: bloomFilters,
                    candidateIndices: candIndices,
                    candidateCounts: candCounts,
                    compactedGaussians: stdCompacted,
                    worldToCompacted: worldToCompacted,
                    maxPerTile: sortedMaxPerTile,
                    maxCandidates: candidatesPerFrame,
                    tileCount: temporalTileCount
                )

                // Spatial reuse for faster convergence
                encoder.encodeSpatialReuse(
                    commandBuffer: cb2,
                    sortedKeys: sortedKeys,
                    sortedIndices: sortedIndices,
                    sortedCounts: sortedCounts,
                    compactedGaussians: stdCompacted,
                    worldToCompacted: worldToCompacted,
                    maxPerTile: sortedMaxPerTile,
                    tilesX: temporalTilesX,
                    tilesY: temporalTilesY,
                    numToSteal: 4
                )

                // Render
                encoder.encodeRenderTemporal(
                    commandBuffer: cb2,
                    compactedGaussians: stdCompacted,
                    sortedCounts: sortedCounts,
                    sortedWorldIndices: sortedIndices,
                    worldToCompacted: worldToCompacted,
                    colorTexture: tmpColorTex,
                    depthTexture: tmpDepthTex,
                    tilesX: temporalTilesX,
                    tilesY: temporalTilesY,
                    width: width,
                    height: height,
                    tileWidth: temporalTileWidth,
                    tileHeight: temporalTileHeight,
                    maxPerTile: sortedMaxPerTile,
                    whiteBackground: false
                )
                cb2.commit()
                cb2.waitUntilCompleted()
                continue  // Skip rest of frame 0 loop body
            }

            // Insertion sort: merge candidates into persistent sorted list (temporal reuse!)
            // Recomputes keys from indices to handle scatter race conditions
            encoder.encodeInsertionSortTemporal(
                commandBuffer: cb,
                sortedKeys: sortedKeys,
                sortedIndices: sortedIndices,
                sortedCounts: sortedCounts,
                bloomFilters: bloomFilters,
                candidateIndices: candIndices,
                candidateCounts: candCounts,
                compactedGaussians: stdCompacted,
                worldToCompacted: worldToCompacted,
                maxPerTile: sortedMaxPerTile,
                maxCandidates: candidatesPerFrame,
                tileCount: temporalTileCount
            )

            // Spatial reuse: steal top candidates from neighboring tiles
            // Dramatically speeds up convergence by spreading good samples
            encoder.encodeSpatialReuse(
                commandBuffer: cb,
                sortedKeys: sortedKeys,
                sortedIndices: sortedIndices,
                sortedCounts: sortedCounts,
                compactedGaussians: stdCompacted,
                worldToCompacted: worldToCompacted,
                maxPerTile: sortedMaxPerTile,
                tilesX: temporalTilesX,
                tilesY: temporalTilesY,
                numToSteal: 4
            )

            // Classic alpha-blending render (deterministic, converges exactly)
            encoder.encodeRenderTemporal(
                commandBuffer: cb,
                compactedGaussians: stdCompacted,
                sortedCounts: sortedCounts,
                sortedWorldIndices: sortedIndices,
                worldToCompacted: worldToCompacted,
                colorTexture: tmpColorTex,
                depthTexture: tmpDepthTex,
                tilesX: temporalTilesX,
                tilesY: temporalTilesY,
                width: width,
                height: height,
                tileWidth: temporalTileWidth,
                tileHeight: temporalTileHeight,
                maxPerTile: sortedMaxPerTile,
                whiteBackground: false
            )

            cb.commit()
            cb.waitUntilCompleted()

            // Debug: Print temporal sorted values for testTile after frame 0
            if frame == 0 {
                let sortedKeysPtr = sortedKeys.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
                let sortedIndicesPtr = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
                let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: temporalTileCount)

                // Use tile 41 (same as standard finds)
                let tmpTestTile = 41
                print("\n=== TEMPORAL SORTED (tile \(tmpTestTile)) ===")
                let tmpTileCount = sortedCountsPtr[tmpTestTile]
                let tmpOffset = tmpTestTile * Int(sortedMaxPerTile)
                print("Tile \(tmpTestTile): count=\(tmpTileCount)")
                for i in 0..<min(Int(tmpTileCount), 20) {
                    let key = sortedKeysPtr[tmpOffset + i]
                    let worldIdx = sortedIndicesPtr[tmpOffset + i]
                    // Look up compacted idx for comparison
                    let worldToCompactedPtr = worldToCompacted.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)
                    let compactedIdx = worldIdx < gaussianCount ? worldToCompactedPtr[Int(worldIdx)] : 0xFFFFFFFF
                    print("  [\(i)] key=\(key) worldIdx=\(worldIdx) compactedIdx=\(compactedIdx)")
                }
                print("")
            }

            // Print loss every few frames
            if frame < 10 || frame % 10 == 0 || frame == numFrames - 1 {
                let (avgDiff, nonZero, totalSorted) = computeLoss()

                // Count actual non-INVALID candidates
                let totalCandidateSlots = temporalTileCount * Int(candidatesPerFrame)
                let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: totalCandidateSlots)
                var totalCandidates: UInt32 = 0
                for s in 0..<totalCandidateSlots {
                    if candIndicesPtr[s] != 0xFFFFFFFF { totalCandidates += 1 }
                }

                print(String(format: "%5d | %8.4f | %7d | %10d | %d", frame, avgDiff, nonZero, totalCandidates, totalSorted))
            }
        }

        // Final comparison
        let (finalAvgDiff, tmpNonZero, _) = computeLoss()

        var stdNonZero = 0
        for i in stride(from: 0, to: stdPixels.count, by: 4) {
            if Float(stdPixels[i]) > 0 || Float(stdPixels[i + 1]) > 0 || Float(stdPixels[i + 2]) > 0 { stdNonZero += 1 }
        }

        print("=======================================")
        print("Standard non-zero: \(stdNonZero), Temporal non-zero: \(tmpNonZero)")
        print("Final avg loss vs standard: \(String(format: "%.4f", finalAvgDiff))")
        print("=======================================\n")

        // Compare temporal to ITSELF across two extra frames
        // For static scene, consecutive frames should be IDENTICAL
        var prevPixels = [Float16](repeating: 0, count: width * height * 4)
        tmpColorTex.getBytes(&prevPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        // Run one more frame
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeRecomputeSortedDepths(
                commandBuffer: cb,
                sortedKeys: sortedKeys,
                sortedIndices: sortedIndices,
                sortedCounts: sortedCounts,
                compactedGaussians: stdCompacted,
                worldToCompacted: worldToCompacted,
                maxPerTile: sortedMaxPerTile,
                tileCount: temporalTileCount,
                tilesX: tilesX
            )
            encoder.encodeRenderTemporal(
                commandBuffer: cb,
                compactedGaussians: stdCompacted,
                sortedCounts: sortedCounts,
                sortedWorldIndices: sortedIndices,
                worldToCompacted: worldToCompacted,
                colorTexture: tmpColorTex,
                depthTexture: tmpDepthTex,
                tilesX: temporalTilesX,
                tilesY: temporalTilesY,
                width: width,
                height: height,
                tileWidth: temporalTileWidth,
                tileHeight: temporalTileHeight,
                maxPerTile: sortedMaxPerTile,
                whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var currPixels = [Float16](repeating: 0, count: width * height * 4)
        tmpColorTex.getBytes(&currPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        // Compare previous frame to current frame
        var selfDiff: Float = 0
        for i in 0..<prevPixels.count {
            selfDiff += abs(Float(prevPixels[i]) - Float(currPixels[i]))
        }
        let avgSelfDiff = selfDiff / Float(width * height)

        print("========== SELF-CONSISTENCY TEST ==========")
        print("Temporal frame N vs frame N+1 avg diff: \(String(format: "%.6f", avgSelfDiff))")
        print("(Should be 0 for static scene with converged sorted list)")
        print("=============================================\n")

        // Both should have output
        XCTAssertGreaterThan(stdNonZero, 0, "Standard should have non-zero pixels")
        XCTAssertGreaterThan(tmpNonZero, 0, "Temporal should have non-zero pixels")
        XCTAssertLessThan(avgSelfDiff, 0.0001, "Temporal should be self-consistent for static scene")
    }

    /// Test that standard (non-temporal) projection works first
    func testStandardProjectionWorks() throws {
        let gaussianCount = 100
        let width = 256
        let height = 256
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount

        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!
        let compactedBuffer = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let headerBuffer = device.makeBuffer(length: 16, options: .storageModeShared)!
        let tileCountsBuffer = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!

        // Fill test data
        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        for i in 0..<gaussianCount {
            let x = Float.random(in: -1..<1)
            let y = Float.random(in: -1..<1)
            let z = Float.random(in: 3..<6)

            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(x, y, z),
                scale: SIMD3<Float>(0.1, 0.1, 0.1),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: 0.9
            )

            harmonicsPtr[i * 3 + 0] = 0.8
            harmonicsPtr[i * 3 + 1] = 0.5
            harmonicsPtr[i * 3 + 2] = 0.3
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // Clear header
        let headerPtr = headerBuffer.contents().bindMemory(to: UInt32.self, capacity: 4)
        headerPtr[0] = 0
        headerPtr[1] = 0

        // Run standard project
        guard let cb = queue.makeCommandBuffer() else { XCTFail("No command buffer"); return }

        encoder.encodeProjectCompact(
            commandBuffer: cb,
            worldGaussians: worldBuffer,
            harmonics: harmonicsBuffer,
            camera: camera,
            gaussianCount: gaussianCount,
            tilesX: tilesX,
            tilesY: tilesY,
            tileWidth: tileWidth,
            tileHeight: tileHeight,
            surfaceWidth: width,
            surfaceHeight: height,
            compactedGaussians: compactedBuffer,
            compactedHeader: headerBuffer,
            tileCounts: tileCountsBuffer,
            maxCompacted: maxCompacted,
            useHalfWorld: false
        )

        cb.commit()
        cb.waitUntilCompleted()

        let visibleCount = headerPtr[0]
        print("Standard projection: visible=\(visibleCount)/\(gaussianCount)")

        XCTAssertGreaterThan(Int(visibleCount), 0, "Standard projection should produce visible gaussians")
    }

    /// Test that temporal mode produces non-black output after a few frames
    func testTemporalProducesOutput() throws {
        print("hasTemporalRender: \(encoder.hasTemporalRender)")

        let gaussianCount = 1000
        let width = 256
        let height = 256
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        let maxPerTile: UInt32 = 256
        let maxCandidates: UInt32 = 32

        // Create buffers
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!
        let compactedBuffer = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!  // CompactedGaussian is 48 bytes
        let headerBuffer = device.makeBuffer(length: 16, options: .storageModeShared)!

        // Temporal buffers
        let sortedSlots = tileCount * Int(maxPerTile)
        let sortedKeysBuffer = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndicesBuffer = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCountsBuffer = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!

        let candidateSlots = tileCount * Int(maxCandidates)
        let candidateCountsBuffer = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candidateKeysBuffer = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candidateIndicesBuffer = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        // Bloom filters for O(1) duplicate detection (64 uints = 2048 bits per tile)
        let bloomFiltersBuffer = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!

        let compactedToWorldBuffer = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompactedBuffer = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        // Textures
        let colorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        colorDesc.usage = [.shaderRead, .shaderWrite]
        colorDesc.storageMode = .shared
        let colorTexture = device.makeTexture(descriptor: colorDesc)!

        let depthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        depthDesc.usage = [.shaderRead, .shaderWrite]
        depthDesc.storageMode = .shared
        let depthTexture = device.makeTexture(descriptor: depthDesc)!

        // Fill test data - gaussians in front of camera
        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        for i in 0..<gaussianCount {
            let x = Float.random(in: -2..<2)
            let y = Float.random(in: -2..<2)
            let z = Float.random(in: 3..<8)  // In front of camera

            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(x, y, z),
                scale: SIMD3<Float>(0.05, 0.05, 0.05),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: 0.8
            )

            harmonicsPtr[i * 3 + 0] = Float.random(in: 0.3..<1.0)  // R
            harmonicsPtr[i * 3 + 1] = Float.random(in: 0.3..<1.0)  // G
            harmonicsPtr[i * 3 + 2] = Float.random(in: 0.3..<1.0)  // B
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // Initialize sorted buffers
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(
                commandBuffer: cb,
                sortedKeys: sortedKeysBuffer,
                sortedIndices: sortedIndicesBuffer,
                sortedCounts: sortedCountsBuffer,
                tileCount: tileCount,
                maxPerTile: maxPerTile
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Get header pointer once
        let headerPtr = headerBuffer.contents().bindMemory(to: UInt32.self, capacity: 4)

        // Run temporal pipeline for multiple frames
        let numFrames = 10
        for frame in 0..<numFrames {
            guard let cb = queue.makeCommandBuffer() else { continue }

            // Clear header, candidate counts and worldToCompacted
            encoder.encodeClearTemporal(
                commandBuffer: cb,
                candidateCounts: candidateCountsBuffer,
                worldToCompacted: worldToCompactedBuffer,
                compactedHeader: headerBuffer,
                candidateIndices: candidateIndicesBuffer,
                tileCount: tileCount,
                maxGaussians: gaussianCount,
                maxCandidates: maxCandidates
            )

            // Project with mapping
            encoder.encodeProjectWithMapping(
                commandBuffer: cb,
                worldGaussians: worldBuffer,
                harmonics: harmonicsBuffer,
                compactedGaussians: compactedBuffer,
                compactedHeader: headerBuffer,
                compactedToWorld: compactedToWorldBuffer,
                worldToCompacted: worldToCompactedBuffer,
                camera: camera,
                gaussianCount: gaussianCount,
                tilesX: tilesX,
                tilesY: tilesY,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                surfaceWidth: width,
                surfaceHeight: height,
                maxCompacted: maxCompacted
            )

            // Scatter candidates (stochastic)
            encoder.encodeScatterCandidates(
                commandBuffer: cb,
                compactedGaussians: compactedBuffer,
                compactedHeader: headerBuffer,
                compactedToWorld: compactedToWorldBuffer,
                candidateCounts: candidateCountsBuffer,
                candidateKeys: candidateKeysBuffer,
                candidateIndices: candidateIndicesBuffer,
                tilesX: tilesX,
                maxCandidates: maxCandidates,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                maxGaussians: maxCompacted,
                frameId: UInt32(frame)
            )

            // Insertion sort
            encoder.encodeInsertionSortTemporal(
                commandBuffer: cb,
                sortedKeys: sortedKeysBuffer,
                sortedIndices: sortedIndicesBuffer,
                sortedCounts: sortedCountsBuffer,
                bloomFilters: bloomFiltersBuffer,
                candidateIndices: candidateIndicesBuffer,
                candidateCounts: candidateCountsBuffer,
                compactedGaussians: compactedBuffer,
                worldToCompacted: worldToCompactedBuffer,
                maxPerTile: maxPerTile,
                maxCandidates: maxCandidates,
                tileCount: tileCount
            )

            // Render
            encoder.encodeRenderTemporal(
                commandBuffer: cb,
                compactedGaussians: compactedBuffer,
                sortedCounts: sortedCountsBuffer,
                sortedWorldIndices: sortedIndicesBuffer,
                worldToCompacted: worldToCompactedBuffer,
                colorTexture: colorTexture,
                depthTexture: depthTexture,
                tilesX: tilesX,
                tilesY: tilesY,
                width: width,
                height: height,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                maxPerTile: maxPerTile,
                whiteBackground: false
            )

            cb.commit()
            cb.waitUntilCompleted()

            // Check visible count (reuse headerPtr from above)
            let visibleCount = headerPtr[0]

            // Check sorted counts for a few tiles
            let sortedCountsPtr = sortedCountsBuffer.contents().bindMemory(to: UInt32.self, capacity: tileCount)
            var totalSorted: UInt32 = 0
            for t in 0..<min(10, tileCount) {
                totalSorted += sortedCountsPtr[t]
            }

            // Check candidate counts
            let candCountsPtr = candidateCountsBuffer.contents().bindMemory(to: UInt32.self, capacity: tileCount)
            var totalCandidates: UInt32 = 0
            for t in 0..<min(10, tileCount) {
                totalCandidates += candCountsPtr[t]
            }

            print("Frame \(frame): visible=\(visibleCount), sorted(first10)=\(totalSorted), candidates(first10)=\(totalCandidates)")
        }

        // Read output texture
        var pixels = [Float16](repeating: 0, count: width * height * 4)
        colorTexture.getBytes(&pixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        // Check that output is not all black
        var maxR: Float16 = 0
        var maxG: Float16 = 0
        var maxB: Float16 = 0
        var nonZeroCount = 0
        for i in stride(from: 0, to: pixels.count, by: 4) {
            let r = pixels[i]
            let g = pixels[i + 1]
            let b = pixels[i + 2]
            if r > 0 || g > 0 || b > 0 {
                nonZeroCount += 1
            }
            maxR = max(maxR, r)
            maxG = max(maxG, g)
            maxB = max(maxB, b)
        }

        print("Output: maxRGB=(\(maxR), \(maxG), \(maxB)), nonZeroPixels=\(nonZeroCount)/\(width*height)")

        // Check sorted buffer contents
        let sortedKeysPtr = sortedKeysBuffer.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedIndicesPtr = sortedIndicesBuffer.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedCountsPtr = sortedCountsBuffer.contents().bindMemory(to: UInt32.self, capacity: tileCount)

        print("\nSorted buffer state (first 5 tiles):")
        for tile in 0..<min(5, tileCount) {
            let count = sortedCountsPtr[tile]
            let offset = tile * Int(maxPerTile)
            var keys: [UInt32] = []
            var indices: [UInt32] = []
            for i in 0..<min(Int(count), 5) {
                keys.append(sortedKeysPtr[offset + i])
                indices.append(sortedIndicesPtr[offset + i])
            }
            print("  Tile \(tile): count=\(count), keys=\(keys), indices=\(indices)")
        }

        // Check worldToCompacted mapping
        let worldToCompactedPtr = worldToCompactedBuffer.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)
        var validMappings = 0
        for i in 0..<gaussianCount {
            if worldToCompactedPtr[i] != 0xFFFFFFFF {
                validMappings += 1
            }
        }
        print("worldToCompacted valid mappings: \(validMappings)/\(gaussianCount)")

        XCTAssertGreaterThan(nonZeroCount, 0, "Temporal render should produce non-black output")
    }

    /// Test: Verify temporal pipeline with STANDARD render kernel
    /// The goal: use temporal scatter+sort, but standard render to isolate the render
    func testTemporalWithStandardRender() throws {
        let gaussianCount = 10_000
        let width = 512
        let height = 512
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        let maxPerTile: UInt32 = 1024  // Increased for convergence
        let maxCandidates: UInt32 = 256  // Increased for fewer hash collisions
        let maxAssignments = gaussianCount * 16

        print("\n╔═══════════════════════════════════════════════════════════╗")
        print("║  TEMPORAL WITH STANDARD RENDER (isolate render kernel)    ║")
        print("║  maxPerTile=\(maxPerTile), maxCandidates=\(maxCandidates)              ║")
        print("╚═══════════════════════════════════════════════════════════╝\n")

        // Create test data
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)
        for i in 0..<gaussianCount {
            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(Float(drand48()) * 2 - 1, Float(drand48()) * 2 - 1, Float(drand48()) * 3 + 3),
                scale: SIMD3<Float>(0.05, 0.05, 0.05),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: Float(drand48()) * 0.5 + 0.5
            )
            harmonicsPtr[i * 3] = Float(drand48())
            harmonicsPtr[i * 3 + 1] = Float(drand48())
            harmonicsPtr[i * 3 + 2] = Float(drand48())
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // ========== STANDARD PIPELINE ==========
        let stdCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let stdHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let stdTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let stdTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let stdPartialSums = device.makeBuffer(length: 1024 * 4, options: .storageModeShared)!
        let stdSortKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdSortIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!
        let stdTempIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!

        let colorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        colorDesc.usage = [.shaderRead, .shaderWrite]; colorDesc.storageMode = .shared
        let stdColorTex = device.makeTexture(descriptor: colorDesc)!
        let tmpColorTex = device.makeTexture(descriptor: colorDesc)!

        let depthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        depthDesc.usage = [.shaderRead, .shaderWrite]; depthDesc.storageMode = .shared
        let stdDepthTex = device.makeTexture(descriptor: depthDesc)!
        let tmpDepthTex = device.makeTexture(descriptor: depthDesc)!

        let stdHeaderPtr = stdHeader.contents().bindMemory(to: UInt32.self, capacity: 4)
        stdHeaderPtr[0] = 0; stdHeaderPtr[1] = 0

        // Run standard pipeline
        if let cb = queue.makeCommandBuffer() {
            encoder.encode(
                commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer,
                camera: camera, gaussianCount: gaussianCount,
                tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight,
                surfaceWidth: width, surfaceHeight: height,
                compactedGaussians: stdCompacted, compactedHeader: stdHeader,
                tileCounts: stdTileCounts, tileOffsets: stdTileOffsets, partialSums: stdPartialSums,
                sortKeys: stdSortKeys, sortIndices: stdSortIndices,
                maxCompacted: maxCompacted, maxAssignments: maxAssignments,
                tempSortKeys: stdTempKeys, tempSortIndices: stdTempIndices
            )
            encoder.encodeRender(
                commandBuffer: cb, compactedGaussians: stdCompacted,
                tileOffsets: stdTileOffsets, tileCounts: stdTileCounts, sortedIndices: stdSortIndices,
                colorTexture: stdColorTex, depthTexture: stdDepthTex,
                tilesX: tilesX, tilesY: tilesY, width: width, height: height,
                tileWidth: tileWidth, tileHeight: tileHeight, whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var stdPixels = [Float16](repeating: 0, count: width * height * 4)
        stdColorTex.getBytes(&stdPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        let stdVisible = stdHeaderPtr[0]
        print("Standard: visible=\(stdVisible)")

        // Count non-zero pixels
        var stdNonZero = 0
        for i in stride(from: 0, to: stdPixels.count, by: 4) {
            if Float(stdPixels[i]) > 0 || Float(stdPixels[i+1]) > 0 || Float(stdPixels[i+2]) > 0 { stdNonZero += 1 }
        }
        print("Standard non-zero pixels: \(stdNonZero)")

        // ========== TEMPORAL PIPELINE (using standard render) ==========
        // The key difference: temporal stores per-tile sorted lists with COMPACTED indices
        // We'll convert temporal's world indices to compacted indices to use standard render

        let tmpCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let tmpHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let sortedSlots = tileCount * Int(maxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candidateSlots = tileCount * Int(maxCandidates)
        let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!
        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        // Initialize
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, tileCount: tileCount, maxPerTile: maxPerTile)
            encoder.encodeClearTemporal(commandBuffer: cb, candidateCounts: candCounts, worldToCompacted: worldToCompacted, compactedHeader: tmpHeader, candidateIndices: candIndices, tileCount: tileCount, maxGaussians: gaussianCount, maxCandidates: maxCandidates)
            encoder.encodeProjectWithMapping(commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, worldToCompacted: worldToCompacted, camera: camera, gaussianCount: gaussianCount, tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight, surfaceWidth: width, surfaceHeight: height, maxCompacted: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)
        for i in 0..<candidateSlots { candIndicesPtr[i] = 0xFFFFFFFF }

        // Run temporal scatter+sort for many frames
        for frame in 0..<256 {
            guard let cb = queue.makeCommandBuffer() else { continue }
            encoder.encodeScatterCandidatesDepth(commandBuffer: cb, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, candidateKeys: candKeys, candidateIndices: candIndices, tilesX: tilesX, maxCandidates: maxCandidates, tileWidth: tileWidth, tileHeight: tileHeight, maxGaussians: maxCompacted, frameId: UInt32(frame))
            encoder.encodeInsertionSortTemporal(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, candidateIndices: candIndices, candidateCounts: candCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, maxCandidates: maxCandidates, tileCount: tileCount)
            if frame % 4 == 0 {
                encoder.encodeSpatialReuse(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, tilesX: tilesX, tilesY: tilesY, numToSteal: 8)
            }
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Convert temporal's sorted WORLD indices to COMPACTED indices for standard render
        // This is the key: temporal stores worldIdx, but standard render expects compactedIdx
        let worldToCompactedPtr = worldToCompacted.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)
        let sortedIndicesPtr = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)

        // Build tileOffsets and tileCounts from sortedCounts
        let tmpTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let tmpTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let tmpSortedCompacted = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!

        let tmpTileOffsetsPtr = tmpTileOffsets.contents().bindMemory(to: UInt32.self, capacity: tileCount + 1)
        let tmpTileCountsPtr = tmpTileCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
        let tmpSortedCompactedPtr = tmpSortedCompacted.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)

        var offset: UInt32 = 0
        for t in 0..<tileCount {
            tmpTileOffsetsPtr[t] = offset
            let count = min(sortedCountsPtr[t], maxPerTile)
            tmpTileCountsPtr[t] = count

            // Convert world indices to compacted indices
            for i in 0..<Int(count) {
                let worldIdx = sortedIndicesPtr[t * Int(maxPerTile) + i]
                if worldIdx == 0xFFFFFFFF || worldIdx >= gaussianCount {
                    tmpSortedCompactedPtr[Int(offset) + i] = 0xFFFFFFFF
                } else {
                    tmpSortedCompactedPtr[Int(offset) + i] = worldToCompactedPtr[Int(worldIdx)]
                }
            }
            offset += count
        }
        tmpTileOffsetsPtr[tileCount] = offset

        print("Temporal: total sorted = \(offset)")

        // Render with STANDARD render kernel
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeRender(
                commandBuffer: cb, compactedGaussians: tmpCompacted,
                tileOffsets: tmpTileOffsets, tileCounts: tmpTileCounts, sortedIndices: tmpSortedCompacted,
                colorTexture: tmpColorTex, depthTexture: tmpDepthTex,
                tilesX: tilesX, tilesY: tilesY, width: width, height: height,
                tileWidth: tileWidth, tileHeight: tileHeight, whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var tmpPixels = [Float16](repeating: 0, count: width * height * 4)
        tmpColorTex.getBytes(&tmpPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        var tmpNonZero = 0
        for i in stride(from: 0, to: tmpPixels.count, by: 4) {
            if Float(tmpPixels[i]) > 0 || Float(tmpPixels[i+1]) > 0 || Float(tmpPixels[i+2]) > 0 { tmpNonZero += 1 }
        }
        print("Temporal non-zero pixels: \(tmpNonZero)")

        // Compare
        var totalDiff: Float = 0
        for i in 0..<stdPixels.count {
            totalDiff += abs(Float(stdPixels[i]) - Float(tmpPixels[i]))
        }
        let avgDiff = totalDiff / Float(width * height)
        print("Avg pixel diff (temporal scatter + standard render): \(String(format: "%.6f", avgDiff))")

        XCTAssertGreaterThan(stdNonZero, 0, "Standard should have output")
        XCTAssertGreaterThan(tmpNonZero, 0, "Temporal should have output")
    }

    /// Test with HONEST scatter (atomic counters, no hash collisions)
    /// This should produce IDENTICAL results to standard if insertion sort is correct
    func testHonestScatterVsStandard() throws {
        let gaussianCount = 10_000
        let width = 512
        let height = 512
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        let maxPerTile: UInt32 = 512
        let maxCandidates: UInt32 = 512  // Large enough to hold all gaussians per tile
        let maxAssignments = gaussianCount * 16

        print("\n╔═══════════════════════════════════════════════════════════╗")
        print("║  HONEST SCATTER TEST (atomic counters, no collisions)     ║")
        print("╚═══════════════════════════════════════════════════════════╝\n")

        // Create test data
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)
        for i in 0..<gaussianCount {
            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(Float(drand48()) * 2 - 1, Float(drand48()) * 2 - 1, Float(drand48()) * 3 + 3),
                scale: SIMD3<Float>(0.05, 0.05, 0.05),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: Float(drand48()) * 0.5 + 0.5
            )
            harmonicsPtr[i * 3] = Float(drand48())
            harmonicsPtr[i * 3 + 1] = Float(drand48())
            harmonicsPtr[i * 3 + 2] = Float(drand48())
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // ========== STANDARD PIPELINE ==========
        let stdCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let stdHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let stdTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let stdTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let stdPartialSums = device.makeBuffer(length: 1024 * 4, options: .storageModeShared)!
        let stdSortKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdSortIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!
        let stdTempIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!

        let colorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        colorDesc.usage = [.shaderRead, .shaderWrite]; colorDesc.storageMode = .shared
        let stdColorTex = device.makeTexture(descriptor: colorDesc)!
        let tmpColorTex = device.makeTexture(descriptor: colorDesc)!

        let depthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        depthDesc.usage = [.shaderRead, .shaderWrite]; depthDesc.storageMode = .shared
        let stdDepthTex = device.makeTexture(descriptor: depthDesc)!
        let tmpDepthTex = device.makeTexture(descriptor: depthDesc)!

        let stdHeaderPtr = stdHeader.contents().bindMemory(to: UInt32.self, capacity: 4)
        stdHeaderPtr[0] = 0; stdHeaderPtr[1] = 0

        // Run standard pipeline
        if let cb = queue.makeCommandBuffer() {
            encoder.encode(
                commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer,
                camera: camera, gaussianCount: gaussianCount,
                tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight,
                surfaceWidth: width, surfaceHeight: height,
                compactedGaussians: stdCompacted, compactedHeader: stdHeader,
                tileCounts: stdTileCounts, tileOffsets: stdTileOffsets, partialSums: stdPartialSums,
                sortKeys: stdSortKeys, sortIndices: stdSortIndices,
                maxCompacted: maxCompacted, maxAssignments: maxAssignments,
                tempSortKeys: stdTempKeys, tempSortIndices: stdTempIndices
            )
            encoder.encodeRender(
                commandBuffer: cb, compactedGaussians: stdCompacted,
                tileOffsets: stdTileOffsets, tileCounts: stdTileCounts, sortedIndices: stdSortIndices,
                colorTexture: stdColorTex, depthTexture: stdDepthTex,
                tilesX: tilesX, tilesY: tilesY, width: width, height: height,
                tileWidth: tileWidth, tileHeight: tileHeight, whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var stdPixels = [Float16](repeating: 0, count: width * height * 4)
        stdColorTex.getBytes(&stdPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        let stdVisible = stdHeaderPtr[0]
        print("Standard: visible=\(stdVisible)")

        // Count total tile assignments from standard
        let stdTileCountsPtr = stdTileCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
        var stdTotalAssignments: UInt32 = 0
        for t in 0..<tileCount { stdTotalAssignments += stdTileCountsPtr[t] }
        print("Standard total tile assignments: \(stdTotalAssignments)")

        // ========== HONEST SCATTER + INSERTION SORT ==========
        let tmpCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let tmpHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let sortedSlots = tileCount * Int(maxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candidateSlots = tileCount * Int(maxCandidates)
        let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!
        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        // Initialize everything
        let candCountsPtr = candCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
        for t in 0..<tileCount { candCountsPtr[t] = 0 }

        let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)
        for i in 0..<candidateSlots { candIndicesPtr[i] = 0xFFFFFFFF }

        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, tileCount: tileCount, maxPerTile: maxPerTile)
            encoder.encodeClearTemporal(commandBuffer: cb, candidateCounts: candCounts, worldToCompacted: worldToCompacted, compactedHeader: tmpHeader, candidateIndices: candIndices, tileCount: tileCount, maxGaussians: gaussianCount, maxCandidates: maxCandidates)
            encoder.encodeProjectWithMapping(commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, worldToCompacted: worldToCompacted, camera: camera, gaussianCount: gaussianCount, tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight, surfaceWidth: width, surfaceHeight: height, maxCompacted: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Print visible count from project with mapping
        let tmpHeaderPtr = tmpHeader.contents().bindMemory(to: UInt32.self, capacity: 4)
        let mappingVisible = tmpHeaderPtr[0]
        print("ProjectWithMapping: visible=\(mappingVisible)")

        // Calculate expected tile assignments from stored bounds
        struct TellusimCompactedLayout {
            var covariance_depth: SIMD4<Float>
            var position_color: SIMD4<Float>
            var min_tile: SIMD2<Int32>
            var max_tile: SIMD2<Int32>
        }
        let compactedPtr = tmpCompacted.contents().bindMemory(to: TellusimCompactedLayout.self, capacity: maxCompacted)
        var expectedTileAssignments: UInt32 = 0
        var maxTilesWide: Int32 = 0
        var maxTilesHigh: Int32 = 0
        for i in 0..<Int(mappingVisible) {
            let g = compactedPtr[i]
            // EXCLUSIVE bounds: maxTile is first tile NOT covered
            let tilesWide = max(0, g.max_tile.x - g.min_tile.x)
            let tilesHigh = max(0, g.max_tile.y - g.min_tile.y)
            expectedTileAssignments += UInt32(tilesWide * tilesHigh)
            maxTilesWide = max(maxTilesWide, tilesWide)
            maxTilesHigh = max(maxTilesHigh, tilesHigh)
        }
        print("ProjectWithMapping: expected tile assignments from stored bounds = \(expectedTileAssignments) (EXCLUSIVE)")
        print("ProjectWithMapping: max tiles wide=\(maxTilesWide), high=\(maxTilesHigh)")
        // Sample first few gaussians
        for i in 0..<min(5, Int(mappingVisible)) {
            let g = compactedPtr[i]
            let px = g.position_color.x
            let py = g.position_color.y
            print("  Gaussian \(i): pos=(\(px), \(py)), tiles=(\(g.min_tile.x)-\(g.max_tile.x), \(g.min_tile.y)-\(g.max_tile.y))")
        }

        // Also check standard compacted bounds
        struct StdCompactedLayout {
            var covariance_depth: SIMD4<Float>
            var position_color: SIMD4<Float>
            var min_tile: SIMD2<Int32>
            var max_tile: SIMD2<Int32>
        }
        let stdCompactedPtr = stdCompacted.contents().bindMemory(to: StdCompactedLayout.self, capacity: maxCompacted)
        var stdExpected: UInt32 = 0
        var stdInvalidCount = 0
        var stdMaxTileArea: Int32 = 0
        for i in 0..<Int(stdVisible) {
            let g = stdCompactedPtr[i]
            // EXCLUSIVE bounds: maxTile is first tile NOT covered
            let tilesWide = g.max_tile.x - g.min_tile.x
            let tilesHigh = g.max_tile.y - g.min_tile.y
            if tilesWide < 0 || tilesHigh < 0 || tilesWide > 100 || tilesHigh > 100 {
                stdInvalidCount += 1
                if stdInvalidCount <= 5 {
                    print("  INVALID bounds at \(i): min=(\(g.min_tile.x), \(g.min_tile.y)), max=(\(g.max_tile.x), \(g.max_tile.y))")
                }
            } else {
                stdExpected += UInt32(tilesWide * tilesHigh)
                stdMaxTileArea = max(stdMaxTileArea, tilesWide * tilesHigh)
            }
        }
        print("Standard compacted: expected from stored bounds = \(stdExpected) (EXCLUSIVE), invalid=\(stdInvalidCount), maxArea=\(stdMaxTileArea)")
        for i in 0..<min(5, Int(stdVisible)) {
            let g = stdCompactedPtr[i]
            let px = g.position_color.x
            let py = g.position_color.y
            print("  Gaussian \(i): pos=(\(px), \(py)), tiles=(\(g.min_tile.x)-\(g.max_tile.x), \(g.min_tile.y)-\(g.max_tile.y))")
        }

        // Re-clear candidate counts for honest scatter
        for t in 0..<tileCount { candCountsPtr[t] = 0 }
        for i in 0..<candidateSlots { candIndicesPtr[i] = 0xFFFFFFFF }

        // Run HONEST scatter (uses atomic counters, no collisions)
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeScatterCandidatesHonest(commandBuffer: cb, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, candidateCounts: candCounts, candidateKeys: candKeys, candidateIndices: candIndices, tilesX: tilesX, maxCandidates: maxCandidates, tileWidth: tileWidth, tileHeight: tileHeight, maxGaussians: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Check honest scatter counts
        var honestTotalCandidates: UInt32 = 0
        var overflowTiles = 0
        for t in 0..<tileCount {
            let count = candCountsPtr[t]
            honestTotalCandidates += min(count, maxCandidates)
            if count > maxCandidates { overflowTiles += 1 }
        }
        print("Honest scatter total candidates: \(honestTotalCandidates) (overflow tiles: \(overflowTiles))")

        // Run insertion sort
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInsertionSortTemporal(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, candidateIndices: candIndices, candidateCounts: candCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, maxCandidates: maxCandidates, tileCount: tileCount)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Convert world indices to compacted and build tileOffsets for standard render
        let worldToCompactedPtr = worldToCompacted.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)
        let sortedIndicesPtr = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)

        let tmpTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let tmpTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let tmpSortedCompacted = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!

        let tmpTileOffsetsPtr = tmpTileOffsets.contents().bindMemory(to: UInt32.self, capacity: tileCount + 1)
        let tmpTileCountsPtr = tmpTileCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
        let tmpSortedCompactedPtr = tmpSortedCompacted.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)

        var offset: UInt32 = 0
        var honestTotalSorted: UInt32 = 0
        for t in 0..<tileCount {
            tmpTileOffsetsPtr[t] = offset
            let count = min(sortedCountsPtr[t], maxPerTile)
            tmpTileCountsPtr[t] = count
            honestTotalSorted += count

            for i in 0..<Int(count) {
                let worldIdx = sortedIndicesPtr[t * Int(maxPerTile) + i]
                if worldIdx == 0xFFFFFFFF || worldIdx >= gaussianCount {
                    tmpSortedCompactedPtr[Int(offset) + i] = 0xFFFFFFFF
                } else {
                    tmpSortedCompactedPtr[Int(offset) + i] = worldToCompactedPtr[Int(worldIdx)]
                }
            }
            offset += count
        }
        tmpTileOffsetsPtr[tileCount] = offset

        print("Honest scatter total sorted: \(honestTotalSorted)")

        // Render with STANDARD render kernel
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeRender(
                commandBuffer: cb, compactedGaussians: tmpCompacted,
                tileOffsets: tmpTileOffsets, tileCounts: tmpTileCounts, sortedIndices: tmpSortedCompacted,
                colorTexture: tmpColorTex, depthTexture: tmpDepthTex,
                tilesX: tilesX, tilesY: tilesY, width: width, height: height,
                tileWidth: tileWidth, tileHeight: tileHeight, whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var tmpPixels = [Float16](repeating: 0, count: width * height * 4)
        tmpColorTex.getBytes(&tmpPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        // Compare
        var totalDiff: Float = 0
        for i in 0..<stdPixels.count {
            totalDiff += abs(Float(stdPixels[i]) - Float(tmpPixels[i]))
        }
        let avgDiff = totalDiff / Float(width * height)
        print("Avg pixel diff (honest scatter + insertion sort): \(String(format: "%.6f", avgDiff))")

        // Note: Different projections cause some difference, but should be small
        print("Note: Difference due to different projection algorithms between standard and temporal")
    }

    /// Test temporal SELF-CONSISTENCY with honest scatter
    /// Run honest scatter + insertion sort multiple frames - output should be IDENTICAL each frame for static scene
    func testHonestScatterSelfConsistency() throws {
        let gaussianCount = 10_000
        let width = 512
        let height = 512
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        let maxPerTile: UInt32 = 512
        let maxCandidates: UInt32 = 512

        print("\n╔═══════════════════════════════════════════════════════════╗")
        print("║  HONEST SCATTER SELF-CONSISTENCY TEST                     ║")
        print("║  (same static data, multiple frames → identical output)   ║")
        print("╚═══════════════════════════════════════════════════════════╝\n")

        // Create test data
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)
        for i in 0..<gaussianCount {
            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(Float(drand48()) * 2 - 1, Float(drand48()) * 2 - 1, Float(drand48()) * 3 + 3),
                scale: SIMD3<Float>(0.05, 0.05, 0.05),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: Float(drand48()) * 0.5 + 0.5
            )
            harmonicsPtr[i * 3] = Float(drand48())
            harmonicsPtr[i * 3 + 1] = Float(drand48())
            harmonicsPtr[i * 3 + 2] = Float(drand48())
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // Temporal pipeline buffers
        let tmpCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let tmpHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let sortedSlots = tileCount * Int(maxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candidateSlots = tileCount * Int(maxCandidates)
        let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!
        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        let colorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        colorDesc.usage = [.shaderRead, .shaderWrite]; colorDesc.storageMode = .shared
        let colorTex = device.makeTexture(descriptor: colorDesc)!

        let depthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        depthDesc.usage = [.shaderRead, .shaderWrite]; depthDesc.storageMode = .shared
        let depthTex = device.makeTexture(descriptor: depthDesc)!

        // Initialize
        let candCountsPtr = candCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
        let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)

        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, tileCount: tileCount, maxPerTile: maxPerTile)
            encoder.encodeClearTemporal(commandBuffer: cb, candidateCounts: candCounts, worldToCompacted: worldToCompacted, compactedHeader: tmpHeader, candidateIndices: candIndices, tileCount: tileCount, maxGaussians: gaussianCount, maxCandidates: maxCandidates)
            encoder.encodeProjectWithMapping(commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, worldToCompacted: worldToCompacted, camera: camera, gaussianCount: gaussianCount, tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight, surfaceWidth: width, surfaceHeight: height, maxCompacted: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        var frame0Pixels = [Float16](repeating: 0, count: width * height * 4)
        var frame1Pixels = [Float16](repeating: 0, count: width * height * 4)

        // Run scatter/sort ONCE, then render twice to verify render is deterministic
        for t in 0..<tileCount { candCountsPtr[t] = 0 }
        for i in 0..<candidateSlots { candIndicesPtr[i] = 0xFFFFFFFF }

        // Honest scatter (once)
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeScatterCandidatesHonest(commandBuffer: cb, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, candidateCounts: candCounts, candidateKeys: candKeys, candidateIndices: candIndices, tilesX: tilesX, maxCandidates: maxCandidates, tileWidth: tileWidth, tileHeight: tileHeight, maxGaussians: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Insertion sort (once)
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInsertionSortTemporal(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, candidateIndices: candIndices, candidateCounts: candCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, maxCandidates: maxCandidates, tileCount: tileCount)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Get pointers for sorted list
        let sortedKeysPtr = sortedKeys.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedIndicesPtr2 = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
        let sortedCountsPtr2 = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)

        // Render twice with same sorted list
        for frame in 0..<2 {
            // NO scatter/sort - just render with the existing sorted list (sorted list is already built above)

            // Convert to compacted indices for standard render
            let worldToCompactedPtr = worldToCompacted.contents().bindMemory(to: UInt32.self, capacity: gaussianCount)
            let sortedIndicesPtr = sortedIndices.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)
            let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)

            let tmpTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
            let tmpTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
            let tmpSortedCompacted = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!

            let tmpTileOffsetsPtr = tmpTileOffsets.contents().bindMemory(to: UInt32.self, capacity: tileCount + 1)
            let tmpTileCountsPtr = tmpTileCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
            let tmpSortedCompactedPtr = tmpSortedCompacted.contents().bindMemory(to: UInt32.self, capacity: sortedSlots)

            var offset: UInt32 = 0
            for t in 0..<tileCount {
                tmpTileOffsetsPtr[t] = offset
                let count = min(sortedCountsPtr[t], maxPerTile)
                tmpTileCountsPtr[t] = count

                for i in 0..<Int(count) {
                    let worldIdx = sortedIndicesPtr[t * Int(maxPerTile) + i]
                    if worldIdx == 0xFFFFFFFF || worldIdx >= gaussianCount {
                        tmpSortedCompactedPtr[Int(offset) + i] = 0xFFFFFFFF
                    } else {
                        tmpSortedCompactedPtr[Int(offset) + i] = worldToCompactedPtr[Int(worldIdx)]
                    }
                }
                offset += count
            }
            tmpTileOffsetsPtr[tileCount] = offset

            print("Frame \(frame): total sorted = \(offset)")

            // Check converted compacted indices for first non-empty tile
            var firstNonEmpty = -1
            for t in 0..<tileCount {
                if tmpTileCountsPtr[t] > 0 {
                    firstNonEmpty = t
                    break
                }
            }
            if firstNonEmpty >= 0 {
                let o = Int(tmpTileOffsetsPtr[firstNonEmpty])
                let c = min(Int(tmpTileCountsPtr[firstNonEmpty]), 5)
                var compacted: [UInt32] = []
                for i in 0..<c {
                    compacted.append(tmpSortedCompactedPtr[o + i])
                }
                print("  Tile \(firstNonEmpty) compacted indices: \(compacted)")
            }

            // Debug: check sorted counts for first few tiles
            var tileCounts: [UInt32] = []
            for t in 0..<min(tileCount, 20) {
                tileCounts.append(sortedCountsPtr2[t])
            }
            print("  First 20 tile sorted counts: \(tileCounts)")

            // Find first non-zero tile
            var nonZeroTile = -1
            for t in 0..<tileCount {
                if sortedCountsPtr2[t] > 0 {
                    nonZeroTile = t
                    break
                }
            }
            if nonZeroTile >= 0 {
                let tileCount_ = min(sortedCountsPtr2[nonZeroTile], 5)
                var keys: [UInt32] = []
                var indices: [UInt32] = []
                let tileOffset = nonZeroTile * Int(maxPerTile)
                for i in 0..<Int(tileCount_) {
                    keys.append(sortedKeysPtr[tileOffset + i])
                    indices.append(sortedIndicesPtr2[tileOffset + i])
                }
                print("  Tile \(nonZeroTile) first \(tileCount_) entries - keys: \(keys.map { String(format: "0x%08X", $0) })")
                print("  Tile \(nonZeroTile) first \(tileCount_) indices: \(indices)")
            } else {
                print("  WARNING: All tiles have 0 sorted entries!")
            }

            // Clear color texture before render
            var zeros = [Float16](repeating: 0, count: width * height * 4)
            colorTex.replace(region: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)),
                            mipmapLevel: 0, withBytes: &zeros, bytesPerRow: width * 4 * 2)

            // Render
            if let cb = queue.makeCommandBuffer() {
                encoder.encodeRender(
                    commandBuffer: cb, compactedGaussians: tmpCompacted,
                    tileOffsets: tmpTileOffsets, tileCounts: tmpTileCounts, sortedIndices: tmpSortedCompacted,
                    colorTexture: colorTex, depthTexture: depthTex,
                    tilesX: tilesX, tilesY: tilesY, width: width, height: height,
                    tileWidth: tileWidth, tileHeight: tileHeight, whiteBackground: false
                )
                cb.commit()
                cb.waitUntilCompleted()
            }

            if frame == 0 {
                colorTex.getBytes(&frame0Pixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)
            } else {
                colorTex.getBytes(&frame1Pixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)
            }
        }

        // Compare frame 0 and frame 1
        var totalDiff: Float = 0
        for i in 0..<frame0Pixels.count {
            totalDiff += abs(Float(frame0Pixels[i]) - Float(frame1Pixels[i]))
        }
        let avgDiff = totalDiff / Float(width * height)
        print("Avg pixel diff between frame 0 and frame 1: \(String(format: "%.6f", avgDiff))")

        XCTAssertEqual(avgDiff, 0.0, "Honest scatter should be perfectly self-consistent")
    }

    /// Test pixel error vs standard at frame checkpoints
    func testPixelErrorAtCheckpoints() throws {
        let gaussianCount = 500_000  // Realistic count
        let width = 1920
        let height = 1080
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY
        let maxCompacted = gaussianCount
        let maxPerTile: UInt32 = 512
        let maxCandidates: UInt32 = 64
        let maxAssignments = gaussianCount * 4

        print("\n╔═══════════════════════════════════════════════════════════╗")
        print("║  PIXEL ERROR VS STANDARD AT CHECKPOINTS                   ║")
        print("╠═══════════════════════════════════════════════════════════╣")
        print("║  Gaussians: \(gaussianCount), Resolution: \(width)x\(height)")
        print("║  maxPerTile: \(maxPerTile), maxCandidates: \(maxCandidates)")
        print("╚═══════════════════════════════════════════════════════════╝\n")

        // Create buffers
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        // Fill test data
        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)
        for i in 0..<gaussianCount {
            let x = Float(drand48()) * 4.0 - 2.0
            let y = Float(drand48()) * 3.0 - 1.5
            let z = Float(drand48()) * 5.0 + 3.0

            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(x, y, z),
                scale: SIMD3<Float>(0.02, 0.02, 0.02),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: Float(drand48()) * 0.5 + 0.5
            )

            harmonicsPtr[i * 3 + 0] = Float(drand48())
            harmonicsPtr[i * 3 + 1] = Float(drand48())
            harmonicsPtr[i * 3 + 2] = Float(drand48())
        }

        var camera = createCamera(width: width, height: height)
        camera.gaussianCount = UInt32(gaussianCount)

        // ========== STANDARD PIPELINE ==========
        let stdCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let stdHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let stdTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let stdTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let stdPartialSums = device.makeBuffer(length: 1024 * 4, options: .storageModeShared)!
        let stdSortKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdSortIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!
        let stdTempIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!

        let stdColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        stdColorDesc.usage = [.shaderRead, .shaderWrite]
        stdColorDesc.storageMode = .shared
        let stdColorTex = device.makeTexture(descriptor: stdColorDesc)!

        let stdDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        stdDepthDesc.usage = [.shaderRead, .shaderWrite]
        stdDepthDesc.storageMode = .shared
        let stdDepthTex = device.makeTexture(descriptor: stdDepthDesc)!

        let stdHeaderPtr = stdHeader.contents().bindMemory(to: UInt32.self, capacity: 4)
        stdHeaderPtr[0] = 0
        stdHeaderPtr[1] = 0

        // Run standard pipeline
        if let cb = queue.makeCommandBuffer() {
            encoder.encode(
                commandBuffer: cb,
                worldGaussians: worldBuffer,
                harmonics: harmonicsBuffer,
                camera: camera,
                gaussianCount: gaussianCount,
                tilesX: tilesX,
                tilesY: tilesY,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                surfaceWidth: width,
                surfaceHeight: height,
                compactedGaussians: stdCompacted,
                compactedHeader: stdHeader,
                tileCounts: stdTileCounts,
                tileOffsets: stdTileOffsets,
                partialSums: stdPartialSums,
                sortKeys: stdSortKeys,
                sortIndices: stdSortIndices,
                maxCompacted: maxCompacted,
                maxAssignments: maxAssignments,
                useHalfWorld: false,
                tempSortKeys: stdTempKeys,
                tempSortIndices: stdTempIndices
            )
            encoder.encodeRender(
                commandBuffer: cb,
                compactedGaussians: stdCompacted,
                tileOffsets: stdTileOffsets,
                tileCounts: stdTileCounts,
                sortedIndices: stdSortIndices,
                colorTexture: stdColorTex,
                depthTexture: stdDepthTex,
                tilesX: tilesX,
                tilesY: tilesY,
                width: width,
                height: height,
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                whiteBackground: false
            )
            cb.commit()
            cb.waitUntilCompleted()
        }

        var stdPixels = [Float16](repeating: 0, count: width * height * 4)
        stdColorTex.getBytes(&stdPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

        let stdVisible = stdHeaderPtr[0]
        print("Standard: visible=\(stdVisible)/\(gaussianCount)")

        // ========== TEMPORAL PIPELINE ==========
        let tmpCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let tmpHeader = device.makeBuffer(length: 16, options: .storageModeShared)!

        let sortedSlots = tileCount * Int(maxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!

        let candidateSlots = tileCount * Int(maxCandidates)
        let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!

        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        let tmpColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        tmpColorDesc.usage = [.shaderRead, .shaderWrite]
        tmpColorDesc.storageMode = .shared
        let tmpColorTex = device.makeTexture(descriptor: tmpColorDesc)!

        let tmpDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        tmpDepthDesc.usage = [.shaderRead, .shaderWrite]
        tmpDepthDesc.storageMode = .shared
        let tmpDepthTex = device.makeTexture(descriptor: tmpDepthDesc)!

        // Initialize
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, tileCount: tileCount, maxPerTile: maxPerTile)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Project once
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeClearTemporal(commandBuffer: cb, candidateCounts: candCounts, worldToCompacted: worldToCompacted, compactedHeader: tmpHeader, candidateIndices: candIndices, tileCount: tileCount, maxGaussians: gaussianCount, maxCandidates: maxCandidates)
            encoder.encodeProjectWithMapping(commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, worldToCompacted: worldToCompacted, camera: camera, gaussianCount: gaussianCount, tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight, surfaceWidth: width, surfaceHeight: height, maxCompacted: maxCompacted)
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Helper to compute loss
        func computePixelError() -> Float {
            var tmpPixels = [Float16](repeating: 0, count: width * height * 4)
            tmpColorTex.getBytes(&tmpPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

            var totalDiff: Float = 0
            for i in stride(from: 0, to: stdPixels.count, by: 4) {
                totalDiff += abs(Float(stdPixels[i]) - Float(tmpPixels[i]))
                totalDiff += abs(Float(stdPixels[i+1]) - Float(tmpPixels[i+1]))
                totalDiff += abs(Float(stdPixels[i+2]) - Float(tmpPixels[i+2]))
            }
            return totalDiff / Float(width * height)
        }

        let checkpoints = [1, 2, 4, 8, 16, 32, 64, 128, 256]
        var results: [(frame: Int, error: Float, sorted: UInt32)] = []

        print("\nFrame | PixelError | TotalSorted")
        print("------|------------|------------")

        let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)
        for i in 0..<candidateSlots { candIndicesPtr[i] = 0xFFFFFFFF }

        for frame in 0..<257 {
            guard let cb = queue.makeCommandBuffer() else { continue }

            encoder.encodeScatterCandidatesDepth(commandBuffer: cb, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, candidateKeys: candKeys, candidateIndices: candIndices, tilesX: tilesX, maxCandidates: maxCandidates, tileWidth: tileWidth, tileHeight: tileHeight, maxGaussians: maxCompacted, frameId: UInt32(frame))

            encoder.encodeInsertionSortTemporal(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, candidateIndices: candIndices, candidateCounts: candCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, maxCandidates: maxCandidates, tileCount: tileCount)

            if frame > 0 && frame % 4 == 0 {
                encoder.encodeSpatialReuse(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: maxPerTile, tilesX: tilesX, tilesY: tilesY, numToSteal: 8)
            }

            encoder.encodeRenderTemporal(commandBuffer: cb, compactedGaussians: tmpCompacted, sortedCounts: sortedCounts, sortedWorldIndices: sortedIndices, worldToCompacted: worldToCompacted, colorTexture: tmpColorTex, depthTexture: tmpDepthTex, tilesX: tilesX, tilesY: tilesY, width: width, height: height, tileWidth: tileWidth, tileHeight: tileHeight, maxPerTile: maxPerTile, whiteBackground: false)

            cb.commit()
            cb.waitUntilCompleted()

            if checkpoints.contains(frame) {
                let error = computePixelError()
                let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
                var totalSorted: UInt32 = 0
                for t in 0..<tileCount { totalSorted += sortedCountsPtr[t] }

                results.append((frame, error, totalSorted))
                print(String(format: "%5d | %10.6f | %10d", frame, error, totalSorted))
            }
        }

        print("\n========== SUMMARY ==========")
        for r in results {
            print(String(format: "Frame %3d: error=%.6f, sorted=%d", r.frame, r.error, r.sorted))
        }
        print("==============================\n")
    }

    /// Test convergence rate with realistic gaussian counts
    func testConvergenceWithRealDataCounts() throws {
        // Test with realistic counts: 100K, 500K, 1M
        let testCases: [(count: Int, label: String)] = [
            (100_000, "100K"),
            (500_000, "500K"),
            (1_000_000, "1M")
        ]

        let width = 1920
        let height = 1080
        let tileWidth = 32
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth  // 60
        let tilesY = (height + tileHeight - 1) / tileHeight  // 68
        let tileCount = tilesX * tilesY  // 4080
        let maxPerTile: UInt32 = 512  // Typical setting
        let maxCandidates: UInt32 = 64  // Stochastic scatter

        print("\n╔═══════════════════════════════════════════════════════════╗")
        print("║  SPATIO-TEMPORAL CONVERGENCE TEST                         ║")
        print("╠═══════════════════════════════════════════════════════════╣")
        print("║  Resolution: \(width)x\(height), Tiles: \(tilesX)x\(tilesY)=\(tileCount)")
        print("║  maxPerTile: \(maxPerTile), maxCandidates: \(maxCandidates)")
        print("╚═══════════════════════════════════════════════════════════╝\n")

        for (gaussianCount, label) in testCases {
            let maxCompacted = gaussianCount

            // Create buffers
            let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
            let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!
            let compactedBuffer = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
            let headerBuffer = device.makeBuffer(length: 16, options: .storageModeShared)!

            let sortedSlots = tileCount * Int(maxPerTile)
            let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
            let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
            let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!

            let candidateSlots = tileCount * Int(maxCandidates)
            let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
            let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
            let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
            let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!

            let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
            let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

            // Fill test data
            let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
            let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

            srand48(42)
            for i in 0..<gaussianCount {
                let x = Float(drand48()) * 4.0 - 2.0
                let y = Float(drand48()) * 3.0 - 1.5
                let z = Float(drand48()) * 5.0 + 3.0

                worldPtr[i] = PackedWorldGaussian(
                    position: SIMD3<Float>(x, y, z),
                    scale: SIMD3<Float>(0.02, 0.02, 0.02),  // Small gaussians (realistic)
                    rotation: SIMD4<Float>(0, 0, 0, 1),
                    opacity: Float(drand48()) * 0.5 + 0.5
                )

                harmonicsPtr[i * 3 + 0] = Float(drand48())
                harmonicsPtr[i * 3 + 1] = Float(drand48())
                harmonicsPtr[i * 3 + 2] = Float(drand48())
            }

            var camera = createCamera(width: width, height: height)
            camera.gaussianCount = UInt32(gaussianCount)

            // Initialize sorted buffers
            if let cb = queue.makeCommandBuffer() {
                encoder.encodeInitSorted(
                    commandBuffer: cb,
                    sortedKeys: sortedKeys,
                    sortedIndices: sortedIndices,
                    sortedCounts: sortedCounts,
                    tileCount: tileCount,
                    maxPerTile: maxPerTile
                )
                cb.commit()
                cb.waitUntilCompleted()
            }

            // Project once
            if let cb = queue.makeCommandBuffer() {
                encoder.encodeClearTemporal(
                    commandBuffer: cb,
                    candidateCounts: candCounts,
                    worldToCompacted: worldToCompacted,
                    compactedHeader: headerBuffer,
                    candidateIndices: candIndices,
                    tileCount: tileCount,
                    maxGaussians: gaussianCount,
                    maxCandidates: maxCandidates
                )
                encoder.encodeProjectWithMapping(
                    commandBuffer: cb,
                    worldGaussians: worldBuffer,
                    harmonics: harmonicsBuffer,
                    compactedGaussians: compactedBuffer,
                    compactedHeader: headerBuffer,
                    compactedToWorld: compactedToWorld,
                    worldToCompacted: worldToCompacted,
                    camera: camera,
                    gaussianCount: gaussianCount,
                    tilesX: tilesX,
                    tilesY: tilesY,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    surfaceWidth: width,
                    surfaceHeight: height,
                    maxCompacted: maxCompacted
                )
                cb.commit()
                cb.waitUntilCompleted()
            }

            let headerPtr = headerBuffer.contents().bindMemory(to: UInt32.self, capacity: 4)
            let visibleCount = headerPtr[0]

            // Track convergence
            var prevTotalSorted: UInt32 = 0
            var convergedFrame = -1
            let maxFrames = 200

            print("[\(label)] Visible: \(visibleCount)/\(gaussianCount)")
            print("Frame | TotalSorted | NewAdded | Converged?")
            print("------|-------------|----------|----------")

            for frame in 0..<maxFrames {
                guard let cb = queue.makeCommandBuffer() else { continue }

                // Clear candidate indices
                if frame == 0 {
                    let candIndicesPtr = candIndices.contents().bindMemory(to: UInt32.self, capacity: candidateSlots)
                    for i in 0..<candidateSlots {
                        candIndicesPtr[i] = 0xFFFFFFFF
                    }
                }

                // Scatter candidates
                encoder.encodeScatterCandidatesDepth(
                    commandBuffer: cb,
                    compactedGaussians: compactedBuffer,
                    compactedHeader: headerBuffer,
                    compactedToWorld: compactedToWorld,
                    candidateKeys: candKeys,
                    candidateIndices: candIndices,
                    tilesX: tilesX,
                    maxCandidates: maxCandidates,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    maxGaussians: maxCompacted,
                    frameId: UInt32(frame)
                )

                // Insertion sort
                encoder.encodeInsertionSortTemporal(
                    commandBuffer: cb,
                    sortedKeys: sortedKeys,
                    sortedIndices: sortedIndices,
                    sortedCounts: sortedCounts,
                    bloomFilters: bloomFilters,
                    candidateIndices: candIndices,
                    candidateCounts: candCounts,
                    compactedGaussians: compactedBuffer,
                    worldToCompacted: worldToCompacted,
                    maxPerTile: maxPerTile,
                    maxCandidates: maxCandidates,
                    tileCount: tileCount
                )

                // Spatial reuse every few frames
                if frame > 0 && frame % 4 == 0 {
                    encoder.encodeSpatialReuse(
                        commandBuffer: cb,
                        sortedKeys: sortedKeys,
                        sortedIndices: sortedIndices,
                        sortedCounts: sortedCounts,
                        compactedGaussians: compactedBuffer,
                        worldToCompacted: worldToCompacted,
                        maxPerTile: maxPerTile,
                        tilesX: tilesX,
                        tilesY: tilesY,
                        numToSteal: 8
                    )
                }

                cb.commit()
                cb.waitUntilCompleted()

                // Count total sorted
                let sortedCountsPtr = sortedCounts.contents().bindMemory(to: UInt32.self, capacity: tileCount)
                var totalSorted: UInt32 = 0
                for t in 0..<tileCount {
                    totalSorted += sortedCountsPtr[t]
                }

                let newAdded = totalSorted - prevTotalSorted
                let isConverged = (newAdded == 0 && frame > 0)

                if frame < 20 || frame % 10 == 0 || isConverged {
                    let convergeStr = isConverged ? "YES" : ""
                    print(String(format: "%5d | %11d | %8d | %s", frame, totalSorted, newAdded, convergeStr))
                }

                if isConverged && convergedFrame < 0 {
                    convergedFrame = frame
                    print("\n>>> [\(label)] CONVERGED at frame \(frame)! <<<\n")
                    break
                }

                prevTotalSorted = totalSorted
            }

            if convergedFrame < 0 {
                print("\n>>> [\(label)] Did NOT converge within \(maxFrames) frames <<<\n")
            }

            print("")
        }
    }

    // MARK: - 1M Gaussian Dynamic Camera Test
    /// Test 30 temporal frames vs 1 non-temporal frame with camera movement
    /// This validates that stale entries are properly evicted when camera moves
    func testDynamicCamera1M() throws {
        print("\n=== 1M GAUSSIAN DYNAMIC CAMERA TEST ===")
        print("Comparing 30 temporal frames vs 1 standard frame per camera position\n")

        let gaussianCount = 1_000_000
        let width = 1024
        let height = 768
        let tileWidth = 16
        let tileHeight = 16
        let tilesX = (width + tileWidth - 1) / tileWidth
        let tilesY = (height + tileHeight - 1) / tileHeight
        let tileCount = tilesX * tilesY

        let maxCompacted = gaussianCount
        let maxAssignments = 16 * 1024 * 1024
        let temporalMaxPerTile: UInt32 = 256
        let temporalMaxCandidates: UInt32 = 32

        // Create gaussian data
        let worldBuffer = device.makeBuffer(length: gaussianCount * MemoryLayout<PackedWorldGaussian>.stride, options: .storageModeShared)!
        let harmonicsBuffer = device.makeBuffer(length: gaussianCount * 3 * MemoryLayout<Float>.stride, options: .storageModeShared)!

        let worldPtr = worldBuffer.contents().bindMemory(to: PackedWorldGaussian.self, capacity: gaussianCount)
        let harmonicsPtr = harmonicsBuffer.contents().bindMemory(to: Float.self, capacity: gaussianCount * 3)

        srand48(42)
        for i in 0..<gaussianCount {
            let x = Float(drand48()) * 10.0 - 5.0
            let y = Float(drand48()) * 8.0 - 4.0
            let z = Float(drand48()) * 10.0 + 2.0

            worldPtr[i] = PackedWorldGaussian(
                position: SIMD3<Float>(x, y, z),
                scale: SIMD3<Float>(0.015, 0.015, 0.015),
                rotation: SIMD4<Float>(0, 0, 0, 1),
                opacity: Float(drand48()) * 0.6 + 0.4
            )

            harmonicsPtr[i * 3 + 0] = Float(drand48())
            harmonicsPtr[i * 3 + 1] = Float(drand48())
            harmonicsPtr[i * 3 + 2] = Float(drand48())
        }

        print("Created \(gaussianCount) gaussians")

        // Standard buffers
        let stdCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let stdHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let stdTileCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let stdTileOffsets = device.makeBuffer(length: (tileCount + 1) * 4, options: .storageModeShared)!
        let stdPartialSums = device.makeBuffer(length: 4096 * 4, options: .storageModeShared)!
        let stdSortKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdSortIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModeShared)!
        let stdTempKeys = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!
        let stdTempIndices = device.makeBuffer(length: maxAssignments * 4, options: .storageModePrivate)!

        let stdColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        stdColorDesc.usage = [.shaderRead, .shaderWrite]; stdColorDesc.storageMode = .shared
        let stdColorTex = device.makeTexture(descriptor: stdColorDesc)!

        let stdDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        stdDepthDesc.usage = [.shaderRead, .shaderWrite]; stdDepthDesc.storageMode = .shared
        let stdDepthTex = device.makeTexture(descriptor: stdDepthDesc)!

        // Temporal buffers
        let tmpCompacted = device.makeBuffer(length: maxCompacted * 48, options: .storageModeShared)!
        let tmpHeader = device.makeBuffer(length: 16, options: .storageModeShared)!
        let sortedSlots = tileCount * Int(temporalMaxPerTile)
        let sortedKeys = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: sortedSlots * 4, options: .storageModeShared)!
        let sortedCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candidateSlots = tileCount * Int(temporalMaxCandidates)
        let candCounts = device.makeBuffer(length: tileCount * 4, options: .storageModeShared)!
        let candKeys = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let candIndices = device.makeBuffer(length: candidateSlots * 4, options: .storageModeShared)!
        let bloomFilters = device.makeBuffer(length: tileCount * 64 * 4, options: .storageModeShared)!
        let compactedToWorld = device.makeBuffer(length: maxCompacted * 4, options: .storageModeShared)!
        let worldToCompacted = device.makeBuffer(length: gaussianCount * 4, options: .storageModeShared)!

        let tmpColorDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba16Float, width: width, height: height, mipmapped: false)
        tmpColorDesc.usage = [.shaderRead, .shaderWrite]; tmpColorDesc.storageMode = .shared
        let tmpColorTex = device.makeTexture(descriptor: tmpColorDesc)!

        let tmpDepthDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r16Float, width: width, height: height, mipmapped: false)
        tmpDepthDesc.usage = [.shaderRead, .shaderWrite]; tmpDepthDesc.storageMode = .shared
        let tmpDepthTex = device.makeTexture(descriptor: tmpDepthDesc)!

        // Helper to create camera with optional offset
        func makeCamera(offsetX: Float = 0, offsetY: Float = 0) -> CameraUniformsSwift {
            var cam = createCamera(width: width, height: height)
            cam.gaussianCount = UInt32(gaussianCount)
            cam.viewMatrix.columns.3.x = -offsetX
            cam.viewMatrix.columns.3.y = -offsetY
            return cam
        }

        // Camera positions - simulate smooth movement
        let cameraOffsets: [(Float, Float)] = [
            (0, 0),         // Initial
            (0.1, 0),       // Slight right
            (0.2, 0.05),    // More right + up
            (0.15, 0.1),    // Settle
        ]

        // Initialize temporal sorted buffers once
        if let cb = queue.makeCommandBuffer() {
            encoder.encodeInitSorted(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, tileCount: tileCount, maxPerTile: temporalMaxPerTile)
            cb.commit(); cb.waitUntilCompleted()
        }

        print("\nFrame | CamPos | StdTime | TmpTime | PixelError | Converged")
        print("------|--------|---------|---------|------------|----------")

        let stdHeaderPtr = stdHeader.contents().bindMemory(to: UInt32.self, capacity: 4)

        for (camIdx, offset) in cameraOffsets.enumerated() {
            let camera = makeCamera(offsetX: offset.0, offsetY: offset.1)
            stdHeaderPtr[0] = 0
            stdHeaderPtr[1] = 0

            // === STANDARD PIPELINE (1 frame) ===
            let stdStart = CFAbsoluteTimeGetCurrent()
            if let cb = queue.makeCommandBuffer() {
                encoder.encode(
                    commandBuffer: cb,
                    worldGaussians: worldBuffer,
                    harmonics: harmonicsBuffer,
                    camera: camera,
                    gaussianCount: gaussianCount,
                    tilesX: tilesX,
                    tilesY: tilesY,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    surfaceWidth: width,
                    surfaceHeight: height,
                    compactedGaussians: stdCompacted,
                    compactedHeader: stdHeader,
                    tileCounts: stdTileCounts,
                    tileOffsets: stdTileOffsets,
                    partialSums: stdPartialSums,
                    sortKeys: stdSortKeys,
                    sortIndices: stdSortIndices,
                    maxCompacted: maxCompacted,
                    maxAssignments: maxAssignments,
                    useHalfWorld: false,
                    tempSortKeys: stdTempKeys,
                    tempSortIndices: stdTempIndices
                )
                encoder.encodeRender(
                    commandBuffer: cb,
                    compactedGaussians: stdCompacted,
                    tileOffsets: stdTileOffsets,
                    tileCounts: stdTileCounts,
                    sortedIndices: stdSortIndices,
                    colorTexture: stdColorTex,
                    depthTexture: stdDepthTex,
                    tilesX: tilesX,
                    tilesY: tilesY,
                    width: width,
                    height: height,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    whiteBackground: false
                )
                cb.commit(); cb.waitUntilCompleted()
            }
            let stdTime = (CFAbsoluteTimeGetCurrent() - stdStart) * 1000

            // Get standard reference pixels
            var stdPixels = [Float16](repeating: 0, count: width * height * 4)
            stdColorTex.getBytes(&stdPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

            // === TEMPORAL PIPELINE (30 frames) ===
            let tmpStart = CFAbsoluteTimeGetCurrent()

            for frame in 0..<100 {
                guard let cb = queue.makeCommandBuffer() else { continue }

                // Clear and project with new camera
                encoder.encodeClearTemporal(commandBuffer: cb, candidateCounts: candCounts, worldToCompacted: worldToCompacted, compactedHeader: tmpHeader, candidateIndices: candIndices, tileCount: tileCount, maxGaussians: gaussianCount, maxCandidates: temporalMaxCandidates)
                encoder.encodeProjectWithMapping(commandBuffer: cb, worldGaussians: worldBuffer, harmonics: harmonicsBuffer, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, worldToCompacted: worldToCompacted, camera: camera, gaussianCount: gaussianCount, tilesX: tilesX, tilesY: tilesY, tileWidth: tileWidth, tileHeight: tileHeight, surfaceWidth: width, surfaceHeight: height, maxCompacted: maxCompacted)

                // INCREMENTAL CAMERA UPDATE: Recompute depths and resort (rebuilds bloom)
                // Only needed on first frame after camera change, but can run every frame
                if camIdx > 0 && frame == 0 {
                    encoder.encodeRecomputeSortedDepths(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: temporalMaxPerTile, tileCount: tileCount, tilesX: tilesX)
                    encoder.encodeResortAfterRecompute(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, maxPerTile: temporalMaxPerTile, tileCount: tileCount)
                }

                // Scatter + Insertion Sort
                encoder.encodeScatterCandidatesDepth(commandBuffer: cb, compactedGaussians: tmpCompacted, compactedHeader: tmpHeader, compactedToWorld: compactedToWorld, candidateKeys: candKeys, candidateIndices: candIndices, tilesX: tilesX, maxCandidates: temporalMaxCandidates, tileWidth: tileWidth, tileHeight: tileHeight, maxGaussians: maxCompacted, frameId: UInt32(frame))
                encoder.encodeInsertionSortTemporal(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, bloomFilters: bloomFilters, candidateIndices: candIndices, candidateCounts: candCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: temporalMaxPerTile, maxCandidates: temporalMaxCandidates, tileCount: tileCount)

                // Spatial reuse every 4 frames
                if frame % 4 == 0 {
                    encoder.encodeSpatialReuse(commandBuffer: cb, sortedKeys: sortedKeys, sortedIndices: sortedIndices, sortedCounts: sortedCounts, compactedGaussians: tmpCompacted, worldToCompacted: worldToCompacted, maxPerTile: temporalMaxPerTile, tilesX: tilesX, tilesY: tilesY, numToSteal: 8)
                }

                // Render
                encoder.encodeRenderTemporal(commandBuffer: cb, compactedGaussians: tmpCompacted, sortedCounts: sortedCounts, sortedWorldIndices: sortedIndices, worldToCompacted: worldToCompacted, colorTexture: tmpColorTex, depthTexture: tmpDepthTex, tilesX: tilesX, tilesY: tilesY, width: width, height: height, tileWidth: tileWidth, tileHeight: tileHeight, maxPerTile: temporalMaxPerTile, whiteBackground: false)

                cb.commit(); cb.waitUntilCompleted()
            }
            let tmpTime = (CFAbsoluteTimeGetCurrent() - tmpStart) * 1000

            // Compare final temporal output to standard
            var tmpPixels = [Float16](repeating: 0, count: width * height * 4)
            tmpColorTex.getBytes(&tmpPixels, bytesPerRow: width * 4 * 2, from: MTLRegion(origin: MTLOrigin(), size: MTLSize(width: width, height: height, depth: 1)), mipmapLevel: 0)

            var totalDiff: Float = 0
            var maxDiff: Float = 0
            for i in stride(from: 0, to: stdPixels.count, by: 4) {
                let diffR = abs(Float(stdPixels[i]) - Float(tmpPixels[i]))
                let diffG = abs(Float(stdPixels[i+1]) - Float(tmpPixels[i+1]))
                let diffB = abs(Float(stdPixels[i+2]) - Float(tmpPixels[i+2]))
                totalDiff += diffR + diffG + diffB
                maxDiff = max(maxDiff, max(diffR, max(diffG, diffB)))
            }
            let avgPixelError = totalDiff / Float(width * height * 3)
            let converged = avgPixelError < 0.01

            print(String(format: "%5d | (%5.2f,%5.2f) | %7.2fms | %7.2fms | %10.4f | %@",
                camIdx,
                offset.0, offset.1,
                stdTime, tmpTime, avgPixelError,
                converged ? "✓" : "✗"))
        }

        print("\nTest complete!")
    }
}
