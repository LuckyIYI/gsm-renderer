import XCTest
import Metal
@testable import GaussianMetalRenderer

/// Unit tests for temporal insertion sort algorithm
/// Tests the core algorithm independently before pipeline integration
final class TemporalInsertionSortTests: XCTestCase {
    var device: MTLDevice!
    var queue: MTLCommandQueue!
    var library: MTLLibrary!
    var insertionSortPipeline: MTLComputePipelineState!

    override func setUp() {
        super.setUp()
        device = MTLCreateSystemDefaultDevice()!
        queue = device.makeCommandQueue()!

        // Load Local library
        let libraryURL = Bundle.module.url(forResource: "LocalShaders", withExtension: "metallib")!
        library = try! device.makeLibrary(URL: libraryURL)
    }

    /// Test basic insertion sort on a single tile
    func testBasicInsertionSort() throws {
        // Create simple insertion sort kernel inline for testing
        let kernelSource = """
        #include <metal_stdlib>
        using namespace metal;

        /// Simple insertion sort for testing
        /// Inserts candidates into a sorted list (single thread per tile)
        kernel void test_insertion_sort(
            device uint* sortedKeys [[buffer(0)]],
            device uint* sortedIndices [[buffer(1)]],
            device uint* sortedCount [[buffer(2)]],
            const device uint* candidateKeys [[buffer(3)]],
            const device uint* candidateIndices [[buffer(4)]],
            constant uint& numCandidates [[buffer(5)]],
            constant uint& maxSorted [[buffer(6)]],
            uint gid [[thread_position_in_grid]]
        ) {
            if (gid != 0) return;  // Single thread

            uint count = *sortedCount;

            for (uint c = 0; c < numCandidates; ++c) {
                uint newKey = candidateKeys[c];
                uint newIdx = candidateIndices[c];

                // Binary search for insertion position
                uint lo = 0, hi = count;
                while (lo < hi) {
                    uint mid = (lo + hi) / 2;
                    if (sortedKeys[mid] < newKey) {
                        lo = mid + 1;
                    } else {
                        hi = mid;
                    }
                }

                // Insert at position lo
                if (count < maxSorted) {
                    // Shift elements down
                    for (uint i = count; i > lo; --i) {
                        sortedKeys[i] = sortedKeys[i - 1];
                        sortedIndices[i] = sortedIndices[i - 1];
                    }
                    sortedKeys[lo] = newKey;
                    sortedIndices[lo] = newIdx;
                    count++;
                } else if (lo < maxSorted) {
                    // Full - shift and insert (drops last element)
                    for (uint i = maxSorted - 1; i > lo; --i) {
                        sortedKeys[i] = sortedKeys[i - 1];
                        sortedIndices[i] = sortedIndices[i - 1];
                    }
                    sortedKeys[lo] = newKey;
                    sortedIndices[lo] = newIdx;
                }
            }

            *sortedCount = count;
        }
        """

        let testLibrary = try device.makeLibrary(source: kernelSource, options: nil)
        let testPipeline = try device.makeComputePipelineState(function: testLibrary.makeFunction(name: "test_insertion_sort")!)

        let maxSorted: UInt32 = 16
        let numCandidates: UInt32 = 5

        // Buffers
        let sortedKeys = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedCount = device.makeBuffer(length: 4, options: .storageModeShared)!
        let candidateKeys = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!
        let candidateIndices = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!

        // Initialize sorted list to empty
        memset(sortedKeys.contents(), 0xFF, Int(maxSorted) * 4)
        memset(sortedIndices.contents(), 0xFF, Int(maxSorted) * 4)
        sortedCount.contents().storeBytes(of: UInt32(0), as: UInt32.self)

        // Candidates: [50, 20, 80, 10, 40] (unsorted depth keys)
        let candKeys: [UInt32] = [50, 20, 80, 10, 40]
        let candIndices: [UInt32] = [0, 1, 2, 3, 4]
        candidateKeys.contents().copyMemory(from: candKeys, byteCount: Int(numCandidates) * 4)
        candidateIndices.contents().copyMemory(from: candIndices, byteCount: Int(numCandidates) * 4)

        var numCandU = numCandidates
        var maxSortedU = maxSorted

        // Run kernel
        let cb = queue.makeCommandBuffer()!
        let enc = cb.makeComputeCommandEncoder()!
        enc.setComputePipelineState(testPipeline)
        enc.setBuffer(sortedKeys, offset: 0, index: 0)
        enc.setBuffer(sortedIndices, offset: 0, index: 1)
        enc.setBuffer(sortedCount, offset: 0, index: 2)
        enc.setBuffer(candidateKeys, offset: 0, index: 3)
        enc.setBuffer(candidateIndices, offset: 0, index: 4)
        enc.setBytes(&numCandU, length: 4, index: 5)
        enc.setBytes(&maxSortedU, length: 4, index: 6)
        enc.dispatchThreads(MTLSize(width: 1, height: 1, depth: 1), threadsPerThreadgroup: MTLSize(width: 1, height: 1, depth: 1))
        enc.endEncoding()
        cb.commit()
        cb.waitUntilCompleted()

        // Check results
        let resultCount = sortedCount.contents().load(as: UInt32.self)
        let resultKeys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(maxSorted)))
        let resultIndices = Array(UnsafeBufferPointer(start: sortedIndices.contents().assumingMemoryBound(to: UInt32.self), count: Int(maxSorted)))

        print("Sorted count: \(resultCount)")
        print("Sorted keys: \(resultKeys.prefix(Int(resultCount)))")
        print("Sorted indices: \(resultIndices.prefix(Int(resultCount)))")

        // Expected: sorted by key [10, 20, 40, 50, 80]
        // Corresponding indices: [3, 1, 4, 0, 2]
        XCTAssertEqual(resultCount, 5)
        XCTAssertEqual(Array(resultKeys.prefix(5)), [10, 20, 40, 50, 80])
        XCTAssertEqual(Array(resultIndices.prefix(5)), [3, 1, 4, 0, 2])

        print("PASS: Basic insertion sort works correctly")
    }

    /// Test temporal accumulation over multiple frames
    func testTemporalAccumulation() throws {
        let kernelSource = """
        #include <metal_stdlib>
        using namespace metal;

        kernel void test_insertion_sort(
            device uint* sortedKeys [[buffer(0)]],
            device uint* sortedIndices [[buffer(1)]],
            device uint* sortedCount [[buffer(2)]],
            const device uint* candidateKeys [[buffer(3)]],
            const device uint* candidateIndices [[buffer(4)]],
            constant uint& numCandidates [[buffer(5)]],
            constant uint& maxSorted [[buffer(6)]],
            uint gid [[thread_position_in_grid]]
        ) {
            if (gid != 0) return;

            uint count = *sortedCount;

            for (uint c = 0; c < numCandidates; ++c) {
                uint newKey = candidateKeys[c];
                uint newIdx = candidateIndices[c];

                // Check for duplicate (same index already in list)
                bool duplicate = false;
                for (uint i = 0; i < count && !duplicate; ++i) {
                    if (sortedIndices[i] == newIdx) duplicate = true;
                }
                if (duplicate) continue;

                uint lo = 0, hi = count;
                while (lo < hi) {
                    uint mid = (lo + hi) / 2;
                    if (sortedKeys[mid] < newKey) lo = mid + 1;
                    else hi = mid;
                }

                if (count < maxSorted) {
                    for (uint i = count; i > lo; --i) {
                        sortedKeys[i] = sortedKeys[i - 1];
                        sortedIndices[i] = sortedIndices[i - 1];
                    }
                    sortedKeys[lo] = newKey;
                    sortedIndices[lo] = newIdx;
                    count++;
                } else if (lo < maxSorted) {
                    for (uint i = maxSorted - 1; i > lo; --i) {
                        sortedKeys[i] = sortedKeys[i - 1];
                        sortedIndices[i] = sortedIndices[i - 1];
                    }
                    sortedKeys[lo] = newKey;
                    sortedIndices[lo] = newIdx;
                }
            }

            *sortedCount = count;
        }
        """

        let testLibrary = try device.makeLibrary(source: kernelSource, options: nil)
        let testPipeline = try device.makeComputePipelineState(function: testLibrary.makeFunction(name: "test_insertion_sort")!)

        let maxSorted: UInt32 = 8  // Small list to test overflow
        let numCandidates: UInt32 = 3

        let sortedKeys = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedCount = device.makeBuffer(length: 4, options: .storageModeShared)!
        let candidateKeys = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!
        let candidateIndices = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!

        // Initialize to empty
        memset(sortedKeys.contents(), 0xFF, Int(maxSorted) * 4)
        memset(sortedIndices.contents(), 0xFF, Int(maxSorted) * 4)
        sortedCount.contents().storeBytes(of: UInt32(0), as: UInt32.self)

        var numCandU = numCandidates
        var maxSortedU = maxSorted

        func runFrame(keys: [UInt32], indices: [UInt32]) {
            candidateKeys.contents().copyMemory(from: keys, byteCount: keys.count * 4)
            candidateIndices.contents().copyMemory(from: indices, byteCount: indices.count * 4)

            let cb = queue.makeCommandBuffer()!
            let enc = cb.makeComputeCommandEncoder()!
            enc.setComputePipelineState(testPipeline)
            enc.setBuffer(sortedKeys, offset: 0, index: 0)
            enc.setBuffer(sortedIndices, offset: 0, index: 1)
            enc.setBuffer(sortedCount, offset: 0, index: 2)
            enc.setBuffer(candidateKeys, offset: 0, index: 3)
            enc.setBuffer(candidateIndices, offset: 0, index: 4)
            enc.setBytes(&numCandU, length: 4, index: 5)
            enc.setBytes(&maxSortedU, length: 4, index: 6)
            enc.dispatchThreads(MTLSize(width: 1, height: 1, depth: 1), threadsPerThreadgroup: MTLSize(width: 1, height: 1, depth: 1))
            enc.endEncoding()
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Frame 0: Insert [50, 30, 70]
        runFrame(keys: [50, 30, 70], indices: [0, 1, 2])
        var count = sortedCount.contents().load(as: UInt32.self)
        var keys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))
        print("Frame 0: count=\(count), keys=\(keys)")
        XCTAssertEqual(count, 3)
        XCTAssertEqual(keys, [30, 50, 70])

        // Frame 1: Insert [20, 40, 60] - should merge
        runFrame(keys: [20, 40, 60], indices: [3, 4, 5])
        count = sortedCount.contents().load(as: UInt32.self)
        keys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))
        print("Frame 1: count=\(count), keys=\(keys)")
        XCTAssertEqual(count, 6)
        XCTAssertEqual(keys, [20, 30, 40, 50, 60, 70])

        // Frame 2: Insert [10, 25, 80] - list becomes full (8 max)
        runFrame(keys: [10, 25, 80], indices: [6, 7, 8])
        count = sortedCount.contents().load(as: UInt32.self)
        keys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))
        print("Frame 2: count=\(count), keys=\(keys)")
        XCTAssertEqual(count, 8)  // Capped at max
        // Should have: [10, 20, 25, 30, 40, 50, 60, 70] (80 dropped because list is full and it's largest)
        XCTAssertEqual(keys, [10, 20, 25, 30, 40, 50, 60, 70])

        // Frame 3: Insert [5, 15, 100] - 5 and 15 should insert, 100 dropped
        runFrame(keys: [5, 15, 100], indices: [9, 10, 11])
        count = sortedCount.contents().load(as: UInt32.self)
        keys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))
        print("Frame 3: count=\(count), keys=\(keys)")
        XCTAssertEqual(count, 8)
        // 5 inserts at front, pushes 70 out. 15 inserts, pushes 60 out. 100 doesn't fit.
        XCTAssertEqual(keys, [5, 10, 15, 20, 25, 30, 40, 50])

        print("PASS: Temporal accumulation works correctly over multiple frames")
    }

    /// Test duplicate handling (same gaussian shouldn't be added twice)
    func testDuplicateHandling() throws {
        let kernelSource = """
        #include <metal_stdlib>
        using namespace metal;

        kernel void test_insertion_sort(
            device uint* sortedKeys [[buffer(0)]],
            device uint* sortedIndices [[buffer(1)]],
            device uint* sortedCount [[buffer(2)]],
            const device uint* candidateKeys [[buffer(3)]],
            const device uint* candidateIndices [[buffer(4)]],
            constant uint& numCandidates [[buffer(5)]],
            constant uint& maxSorted [[buffer(6)]],
            uint gid [[thread_position_in_grid]]
        ) {
            if (gid != 0) return;

            uint count = *sortedCount;

            for (uint c = 0; c < numCandidates; ++c) {
                uint newKey = candidateKeys[c];
                uint newIdx = candidateIndices[c];

                // Check for duplicate
                bool duplicate = false;
                for (uint i = 0; i < count && !duplicate; ++i) {
                    if (sortedIndices[i] == newIdx) duplicate = true;
                }
                if (duplicate) continue;

                uint lo = 0, hi = count;
                while (lo < hi) {
                    uint mid = (lo + hi) / 2;
                    if (sortedKeys[mid] < newKey) lo = mid + 1;
                    else hi = mid;
                }

                if (count < maxSorted) {
                    for (uint i = count; i > lo; --i) {
                        sortedKeys[i] = sortedKeys[i - 1];
                        sortedIndices[i] = sortedIndices[i - 1];
                    }
                    sortedKeys[lo] = newKey;
                    sortedIndices[lo] = newIdx;
                    count++;
                }
            }

            *sortedCount = count;
        }
        """

        let testLibrary = try device.makeLibrary(source: kernelSource, options: nil)
        let testPipeline = try device.makeComputePipelineState(function: testLibrary.makeFunction(name: "test_insertion_sort")!)

        let maxSorted: UInt32 = 16
        let numCandidates: UInt32 = 5

        let sortedKeys = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedIndices = device.makeBuffer(length: Int(maxSorted) * 4, options: .storageModeShared)!
        let sortedCount = device.makeBuffer(length: 4, options: .storageModeShared)!
        let candidateKeys = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!
        let candidateIndices = device.makeBuffer(length: Int(numCandidates) * 4, options: .storageModeShared)!

        memset(sortedKeys.contents(), 0xFF, Int(maxSorted) * 4)
        memset(sortedIndices.contents(), 0xFF, Int(maxSorted) * 4)
        sortedCount.contents().storeBytes(of: UInt32(0), as: UInt32.self)

        var numCandU = numCandidates
        var maxSortedU = maxSorted

        func runFrame(keys: [UInt32], indices: [UInt32]) {
            candidateKeys.contents().copyMemory(from: keys, byteCount: keys.count * 4)
            candidateIndices.contents().copyMemory(from: indices, byteCount: indices.count * 4)

            let cb = queue.makeCommandBuffer()!
            let enc = cb.makeComputeCommandEncoder()!
            enc.setComputePipelineState(testPipeline)
            enc.setBuffer(sortedKeys, offset: 0, index: 0)
            enc.setBuffer(sortedIndices, offset: 0, index: 1)
            enc.setBuffer(sortedCount, offset: 0, index: 2)
            enc.setBuffer(candidateKeys, offset: 0, index: 3)
            enc.setBuffer(candidateIndices, offset: 0, index: 4)
            enc.setBytes(&numCandU, length: 4, index: 5)
            enc.setBytes(&maxSortedU, length: 4, index: 6)
            enc.dispatchThreads(MTLSize(width: 1, height: 1, depth: 1), threadsPerThreadgroup: MTLSize(width: 1, height: 1, depth: 1))
            enc.endEncoding()
            cb.commit()
            cb.waitUntilCompleted()
        }

        // Frame 0: Insert [50, 30, 70] with indices [0, 1, 2]
        runFrame(keys: [50, 30, 70], indices: [0, 1, 2])

        // Frame 1: Try to insert same indices with different keys - should be ignored
        runFrame(keys: [10, 20, 90], indices: [0, 1, 2])

        let count = sortedCount.contents().load(as: UInt32.self)
        let keys = Array(UnsafeBufferPointer(start: sortedKeys.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))
        let indices = Array(UnsafeBufferPointer(start: sortedIndices.contents().assumingMemoryBound(to: UInt32.self), count: Int(count)))

        print("After duplicate frame: count=\(count), keys=\(keys), indices=\(indices)")

        // Should still have original 3 entries, duplicates ignored
        XCTAssertEqual(count, 3)
        XCTAssertEqual(keys, [30, 50, 70])  // Original keys, not new ones
        XCTAssertEqual(indices, [1, 0, 2])

        print("PASS: Duplicate handling works correctly")
    }

    /// Test scatter sampling patterns
    func testScatterSamplingSequential() throws {
        // Test sequential sampling: N[offset..<offset+M]
        let N = 100  // Total gaussians
        let M = 10   // Sample size per frame

        var allSampled: Set<Int> = []

        for frame in 0..<10 {
            let offset = (frame * M) % N
            let samples = Array(offset..<min(offset + M, N))
            allSampled.formUnion(samples)
            print("Frame \(frame): samples \(samples)")
        }

        print("Total unique sampled: \(allSampled.count)")
        XCTAssertEqual(allSampled.count, N)  // Should cover all after N/M frames
        print("PASS: Sequential sampling covers all elements")
    }
}
